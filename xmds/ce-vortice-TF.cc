// ********************************************************
// simulation logging

#define _SAMPLE_LOG_LEVEL             (1 << 0)
#define _SEGMENT_LOG_LEVEL            (1 << 1)
#define _PATH_LOG_LEVEL               (1 << 2)
#define _SIMULATION_LOG_LEVEL         (1 << 3)
#define _WARNING_LOG_LEVEL            (1 << 4)
#define _ERROR_LOG_LEVEL              (1 << 5)
#define _NO_ERROR_TERMINATE_LOG_LEVEL (1 << 6)
#define _ALL_LOG_LEVELS        _SAMPLE_LOG_LEVEL|_SEGMENT_LOG_LEVEL|_PATH_LOG_LEVEL|_SIMULATION_LOG_LEVEL|_WARNING_LOG_LEVEL|_ERROR_LOG_LEVEL|_NO_ERROR_TERMINATE_LOG_LEVEL
#define _LOG_LEVELS_BEING_LOGGED (_ALL_LOG_LEVELS)

#include <stdio.h>

#define _LOG(logLevel, ...) \
  do { \
    if (logLevel & _LOG_LEVELS_BEING_LOGGED) { \
      if ((_rank == 0) || (logLevel & ~(_SIMULATION_LOG_LEVEL | _SEGMENT_LOG_LEVEL | _SAMPLE_LOG_LEVEL | _NO_ERROR_TERMINATE_LOG_LEVEL))) { \
        if (logLevel & ~(_SIMULATION_LOG_LEVEL | _SEGMENT_LOG_LEVEL | _SAMPLE_LOG_LEVEL | _NO_ERROR_TERMINATE_LOG_LEVEL)) \
          printf("Rank[%i]: ", _rank); \
        if (logLevel & (_ERROR_LOG_LEVEL | _WARNING_LOG_LEVEL)) \
            printf("%s:%i: ", __FILE__, __LINE__); \
        printf(__VA_ARGS__); \
        fflush(stdout); \
      } \
      if (logLevel & _ERROR_LOG_LEVEL) \
        MPI_Abort(MPI_COMM_WORLD, 1); \
      else if (logLevel & _NO_ERROR_TERMINATE_LOG_LEVEL) \
        MPI_Finalize(); \
      if (logLevel & (_ERROR_LOG_LEVEL | _NO_ERROR_TERMINATE_LOG_LEVEL)) \
        exit(logLevel == _ERROR_LOG_LEVEL); \
    } \
  } while (0)

// ********************************************************
// simulation includes

#include <xpdeint_platform.h>
#include <cmath>
#include <string>
#include <cstring>
#include <fstream>
#include <sstream>
#include <cstdlib>

#if CFG_OSAPI == CFG_OSAPI_POSIX // These are POSIX headers (i.e. non-windows)
  #include <sys/time.h>
#endif // POSIX

#ifdef __APPLE__
  #include <Availability.h>
  #if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1080
    #define OS_OBJECT_USE_OBJC 0 // Don't make dispatch and xpc objects Objective-C objects.
    #include <IOKit/pwr_mgt/IOPMLib.h> // To disable user idle sleep on Mountain Lion
  #endif
#endif

#include <time.h>
#include <list>
#include <vector>
#include <algorithm>

#include <mpi.h>

#include <utility>
#include <map>

#include <getopt.h>

#if (CFG_COMPILER == CFG_COMPILER_MSVC)
  #define FFTW_DLL
#endif

#define xmds_malloc fftw_malloc
#define xmds_free fftw_free

#include <fftw3.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fftw3-mpi.h>

#if   defined(CBLAS_MKL)
  #include <mkl.h>
#elif defined(CBLAS_VECLIB)
  #include <vecLib/cblas.h>
#elif defined(CBLAS_ATLAS)
  extern "C" {
    #include <cblas.h>
  }
#elif defined(CBLAS_GSL)
  #include <gsl/gsl_cblas.h>
#endif

#define H5_USE_16_API
#include <hdf5.h>

#if !defined(HAVE_H5LEXISTS)
htri_t H5Lexists(hid_t loc_id, const char *name, hid_t lapl_id)
{
  H5E_auto_t error_func;
  void* error_client_data;
  // Squelch errors generated by H5Gget_objinfo. It will report errors when it can't find an object
  // but that's the purpose of calling it.
  H5Eget_auto(&error_func, &error_client_data);
  H5Eset_auto(NULL, NULL);
  herr_t err = H5Gget_objinfo(loc_id, name, false, NULL);
  H5Eset_auto(error_func, error_client_data);
  if (err >= 0)
    return true;
  else
    return false;
}
#endif

#define H5T_NATIVE_REAL H5T_NATIVE_DOUBLE
#if defined(HAVE_HDF5_HL)
  #include <hdf5_hl.h>
#endif


#define complex Complex
#define real Re
#define imag Im
#include <complex>
#undef complex
#undef real
#undef imag

typedef long integer;
typedef double real;
typedef std::Complex<real> complex;

const complex i(0.0, 1.0);

#include <xpdeint.h>

using namespace std;

#if CFG_COMPILER == CFG_COMPILER_ICC
  //
  // Disable ICC's warning: label was declared but never referenced
  //
  #pragma warning ( disable : 177 )
#endif

// ********************************************************
// DEFINES
// ********************************************************

// ********************************************************
//   Simulation defines
#define _EPSILON 1e-6
#ifndef INFINITY
#define INFINITY HUGE_VAL
#endif

#ifndef MAX
#define MAX(a, b) \
  ({ typeof(a) _a = (a); \
     typeof(b) _b = (b); \
     _a > _b ? _a : _b; })
#endif

#ifndef MIN
#define MIN(a, b) \
   ({ typeof(a) _a = (a); \
      typeof(b) _b = (b); \
      _a < _b ? _a : _b; })
#endif


// ********************************************************
//   Distributed MPI Simulation Driver defines
#undef MPI_REAL
#define MPI_REAL MPI_DOUBLE

// ********************************************************
//   Geometry defines
#define _lattice_r ((int)128)
#define _min_r     (_r[0])
#define _max_r     (_r[_lattice_r-1])

#define _lattice_kr ((int)128)
#define _min_kr     (_kr[0])
#define _max_kr     (_kr[_lattice_kr-1])

#define _lattice_z ((int)128)
#define _min_z     ((real)-15)
#define _max_z     ((real)15)
#define _dz        ((real)((_max_z - _min_z)/_lattice_z))

#define _lattice_kz ((int)128)
#define _dkz        (2.0*M_PI/(_max_z - _min_z))
#define _min_kz     (-(_lattice_kz/2) * _dkz)
#define _max_kz     ((_lattice_kz - 1)/2 * _dkz)

// ********************************************************
//   field rz defines
#define _rz_ndims 2


// vector init defines
#define _rz_init_ncomponents 1

// vector main defines
#define _rz_main_ncomponents 1

// ********************************************************
//   field dimensionless defines
#define _dimensionless_ndims 0


// vector normalisation defines
#define _dimensionless_normalisation_ncomponents 1

// ********************************************************
//   segment 1 (RK45 adaptive-step integrator) defines
// vector segment1_rz_operators_operator0_field defines
#define _rz_segment1_rz_operators_operator0_field_ncomponents 2

// vector segment1_rz_operators_operator0_result defines
#define _rz_segment1_rz_operators_operator0_result_ncomponents 2

// ********************************************************
//   field mg0_sampling defines
#define _mg0_sampling_ndims 2


// ********************************************************
//   field mg0_output defines
#define _mg0_output_ndims 1


#define _mg0_output_lattice_t ((int)1001)
#define _mg0_output_min_t     (_mg0_output_t[0])
#define _mg0_output_max_t     (_mg0_output_t[_mg0_output_lattice_t-1])
#define _mg0_output_dt        (_mg0_output_t[_index_t+1]-_mg0_output_t[_index_t])

// vector raw defines
#define _mg0_output_raw_ncomponents 1

// ********************************************************
//   field mg1_sampling defines
#define _mg1_sampling_ndims 2


// ********************************************************
//   field mg1_output defines
#define _mg1_output_ndims 1


#define _mg1_output_lattice_t ((int)1001)
#define _mg1_output_min_t     (_mg1_output_t[0])
#define _mg1_output_max_t     (_mg1_output_t[_mg1_output_lattice_t-1])
#define _mg1_output_dt        (_mg1_output_t[_index_t+1]-_mg1_output_t[_index_t])

// vector raw defines
#define _mg1_output_raw_ncomponents 1

// ********************************************************
//   field mg2_sampling defines
#define _mg2_sampling_ndims 2


// ********************************************************
//   field mg2_output defines
#define _mg2_output_ndims 1


#define _mg2_output_lattice_t ((int)1001)
#define _mg2_output_min_t     (_mg2_output_t[0])
#define _mg2_output_max_t     (_mg2_output_t[_mg2_output_lattice_t-1])
#define _mg2_output_dt        (_mg2_output_t[_index_t+1]-_mg2_output_t[_index_t])

// vector raw defines
#define _mg2_output_raw_ncomponents 1


// ********************************************************
// GLOBALS
// ********************************************************


// ********************************************************
//   Simulation globals

string gsArgsAndValues = "";
  
real t;

// ********************************************************
//   Distributed MPI Simulation Driver globals
int _rank, _size;

// ********************************************************
//   Transform Multiplexer globals
typedef pair<ptrdiff_t, ptrdiff_t> _basis_pair;
typedef void (*transform_function)(bool, real, real* const __restrict__, real* const __restrict__, ptrdiff_t, ptrdiff_t);

// Less than operator needed by the C++ map class
struct _basis_pair_less_than
{
  bool operator()(const _basis_pair& _x, const _basis_pair& _y) const {
    return (_x.first < _y.first) || ((_x.first == _y.first) && (_x.second < _y.second));
  }
};

struct _transform_step
{
  transform_function _func;
  bool _forward;
  bool _out_of_place;
  ptrdiff_t _prefix_lattice;
  ptrdiff_t _postfix_lattice;
};

// Structure to hold the basis change information
struct _basis_transform_t
{
  vector<_transform_step> _transform_steps;
  real _multiplier;
  
  _basis_transform_t(real _multiplier_in = 1.0) : _multiplier(_multiplier_in) {}
  
  _basis_transform_t(const _basis_transform_t& _b) : _transform_steps(_b._transform_steps), _multiplier(_b._multiplier) {}
  
  void append(transform_function _func, bool _forward, bool _out_of_place, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
  {
    _transform_steps.push_back((_transform_step){_func, _forward, _out_of_place, _prefix_lattice, _postfix_lattice});
  }
};

// Map type for holding (old_basis, new_basis) -> _basis_transform_t mappings
typedef map<_basis_pair, _basis_transform_t, _basis_pair_less_than> _basis_map;

_basis_map _rz_segment1_rz_operators_operator0_result_basis_map;
_basis_map _rz_main_basis_map;

real *_auxiliary_array = NULL;

const char *_basis_identifiers[] = {
  /* 0 */ "(kz, distributed kr)",
  /* 1 */ "(r, distributed z)",
};

// ********************************************************
//   Command line argument processing globals
real mu = 20.74; 
real g = 800.0; 
real lamb = 0.9; 
real R = 6.4219; 
real Z = 7.10582; 
real X = 0.255784; 
real A = 0.0455999; 

// ********************************************************
//   FFTW3 with MPI globals
const real _inverse_sqrt_2pi = 1.0 / sqrt(2.0 * M_PI); 
string _fftwWisdomPath;
ptrdiff_t _block_size_r = FFTW_MPI_DEFAULT_BLOCK;
ptrdiff_t _block_size_kr = FFTW_MPI_DEFAULT_BLOCK;
ptrdiff_t _block_size_z = FFTW_MPI_DEFAULT_BLOCK;
ptrdiff_t _block_size_kz = FFTW_MPI_DEFAULT_BLOCK;

// ********************************************************
//   Geometry globals
real* _r = NULL;
ptrdiff_t _local_unswapped_lattice_r = 0;
ptrdiff_t _local_unswapped_offset_r = 0;
real* _dr_array = (real*) xmds_malloc(sizeof(real) * (_lattice_r));

real* _kr = NULL;
ptrdiff_t _local_unswapped_lattice_kr = 0;
ptrdiff_t _local_unswapped_offset_kr = 0;
real* _dkr_array = (real*) xmds_malloc(sizeof(real) * (_lattice_kr));

real* _z = NULL;
ptrdiff_t _local_swapped_lattice_z = 0;
ptrdiff_t _local_swapped_offset_z = 0;

real* _kz = NULL;
ptrdiff_t _local_swapped_lattice_kz = 0;
ptrdiff_t _local_swapped_offset_kz = 0;

// ********************************************************
//   MMT globals
const real _normbesseljzeros_r[] = {
  0.009436538996609515, 0.017277645442670447, 0.025054722239578442,
  0.03281294011425198, 0.04056306615964533, 0.04830898174997062,
  0.05605242821174904, 0.06379430303650313, 0.07153511577578811,
  0.07927517720046699, 0.0870146876166781, 0.09475378194016144,
  0.10249255436568042, 0.11023107265199726, 0.11796938678778914,
  0.12570753445846902, 0.13344554461183258, 0.14118343985161771,
  0.14892123808512212, 0.15665895368269797, 0.16439659830989664,
  0.17213418153523724, 0.17987171128114643, 0.18760919416333474,
  0.19534663574953537, 0.20308404075910688, 0.21082141321868958,
  0.21855875658480414, 0.2262960738413034, 0.23403336757749557,
  0.2417706400512689, 0.24950789324047246, 0.2572451288850259,
  0.2649823485216522, 0.27271955351269933, 0.28045674507019086,
  0.28819392427600343, 0.2959310920988787, 0.30366824940883524,
  0.31140539698943204, 0.31914253554824795, 0.32687966572587335,
  0.33461678810365436, 0.342353903210387, 0.3500910115281235,
  0.35782811349722576, 0.3655652095207771, 0.3733022999684448,
  0.38103938517987296, 0.38877646546766975, 0.3965135411200448,
  0.4042506124031442, 0.41198767956312204, 0.4197247428279831,
  0.42746180240922516, 0.43519885850330614, 0.442935911292958,
  0.4506729609483647, 0.45841000762822093, 0.4661470514806858,
  0.4738840926442429, 0.4816211312484773, 0.4893581674147789,
  0.49709520125698053, 0.5048322328819367, 0.5125692623900503,
  0.5203062898757524, 0.52804331542794, 0.5357803391303747,
  0.5435173610620492, 0.5512543812975215, 0.5589913999072217,
  0.566728416957734, 0.5744654325120557, 0.5822024466298352,
  0.5899394593675921, 0.5976764707789192, 0.6054134809146696,
  0.6131504898231303, 0.6208874975501809, 0.6286245041394425,
  0.6363615096324149, 0.644098514068604, 0.6518355174856396,
  0.6595725199193865, 0.6673095214040459, 0.6750465219722509,
  0.6827835216551558, 0.6905205204825184, 0.6982575184827778,
  0.7059945156831263, 0.7137315121095772, 0.7214685077870279,
  0.7292055027393191, 0.7369424969892906, 0.7446794905588326,
  0.7524164834689354, 0.7601534757397344, 0.7678904673905534,
  0.7756274584399457, 0.7833644489057311, 0.7911014388050326,
  0.7988384281543096, 0.8065754169693902, 0.8143124052655009,
  0.8220493930572949, 0.8297863803588789, 0.8375233671838382,
  0.8452603535452613, 0.8529973394557611, 0.8607343249274972,
  0.8684713099721963, 0.8762082946011706, 0.8839452788253359,
  0.8916822626552299, 0.8994192461010271, 0.9071562291725552,
  0.9148932118793094, 0.9226301942304663, 0.9303671762348974,
  0.9381041579011815, 0.9458411392376166, 0.9535781202522315,
  0.9613151009527965, 0.9690520813468337, 0.976789061441627,
  0.9845260412442312, 0.9922630207614811
  };
const real _besseljnorm_r = 406.049926947180401;

// ********************************************************
//   field rz globals
// vector init globals
size_t _rz_init_alloc_size = 0;
real* _rz_init = NULL;
real* _active_rz_init = NULL;

// vector main globals
size_t _rz_main_alloc_size = 0;
complex* _rz_main = NULL;
complex* _active_rz_main = NULL;

ptrdiff_t _rz_main_basis = -1;

// ********************************************************
//   field dimensionless globals
// vector normalisation globals
size_t _dimensionless_normalisation_alloc_size = 0;
real* _dimensionless_normalisation = NULL;
real* _active_dimensionless_normalisation = NULL;

// ********************************************************
//   segment 1 (RK45 adaptive-step integrator) globals
complex* _segment1_akfield_rz_main;
complex* _segment1_aifield_rz_main;
complex* _segment1_ajfield_rz_main;
complex* _segment1_alfield_rz_main;
complex* _segment1_checkfield_rz_main;

// vector segment1_rz_operators_operator0_field globals
size_t _rz_segment1_rz_operators_operator0_field_alloc_size = 0;
complex* _rz_segment1_rz_operators_operator0_field = NULL;
complex* _active_rz_segment1_rz_operators_operator0_field = NULL;

// vector segment1_rz_operators_operator0_result globals
size_t _rz_segment1_rz_operators_operator0_result_alloc_size = 0;
complex* _rz_segment1_rz_operators_operator0_result = NULL;
complex* _active_rz_segment1_rz_operators_operator0_result = NULL;

ptrdiff_t _rz_segment1_rz_operators_operator0_result_basis = -1;

// ********************************************************
//   field mg0_output globals
real* _mg0_output_t = NULL;
unsigned long _mg0_output_index_t = 0;

// vector raw globals
size_t _mg0_output_raw_alloc_size = 0;
real* _mg0_output_raw = NULL;
real* _active_mg0_output_raw = NULL;

// ********************************************************
//   field mg1_output globals
real* _mg1_output_t = NULL;
unsigned long _mg1_output_index_t = 0;

// vector raw globals
size_t _mg1_output_raw_alloc_size = 0;
real* _mg1_output_raw = NULL;
real* _active_mg1_output_raw = NULL;

// ********************************************************
//   field mg2_output globals
real* _mg2_output_t = NULL;
unsigned long _mg2_output_index_t = 0;

// vector raw globals
size_t _mg2_output_raw_alloc_size = 0;
real* _mg2_output_raw = NULL;
real* _active_mg2_output_raw = NULL;


// ********************************************************
// FUNCTION PROTOTYPES
// ********************************************************

// ********************************************************
//   Transform Multiplexer function prototypes
void _transform_0(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice);
void _transform_1(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice);
void _transform_2(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice);
void _transform_3(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice);
void _transform_4(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice);
void _transform_5(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice);

// ********************************************************
//   Command line argument processing function prototypes
void _print_usage();

// ********************************************************
//   field rz function prototypes
void _rz_init_initialise();

void _rz_main_initialise();
void _rz_main_basis_transform(ptrdiff_t new_basis);

// ********************************************************
//   field dimensionless function prototypes
void _dimensionless_normalisation_evaluate();
void _dimensionless_normalisation_initialise();

// ********************************************************
//   segment 0 (Top level sequence) function prototypes
void _segment0();

// ********************************************************
//   segment 1 (RK45 adaptive-step integrator) function prototypes
inline void _segment1_calculate_delta_a(real _step);
inline void _segment1_calculate_nonconstant_ip_fields(real _step, int _exponent, int _arrayIndex);
void _segment1();
inline void _segment1_ip_evolve(int _exponent);
real _segment1_setup_sampling(bool* _next_sample_flag, long* _next_sample_counter);
real _segment1_rz_main_timestep_error(complex* _checkfield);
bool _segment1_rz_main_reset(complex* _reset_to);

void _segment1_rz_operators_evaluate_operator0();
void _segment1_rz_operators_calculate_operator0_field();

void _rz_segment1_rz_operators_operator0_result_basis_transform(ptrdiff_t new_basis);

void _segment1_rz_operators_evaluate_operator1(real _step);

// ********************************************************
//   output function prototypes
void _write_output();

FILE* _open_xsil_file(const char* _filename);
void _close_xsil_file(FILE*& fp);
void _write_xsil_header(FILE* fp);
void _write_xsil_footer(FILE* fp);

// ********************************************************
//   moment group 0 function prototypes
void _mg0_sample();
void _mg0_process();
void _mg0_write_out(FILE* _outfile);

// ********************************************************
//   field mg0_output function prototypes
void _mg0_output_raw_initialise();

// ********************************************************
//   moment group 1 function prototypes
void _mg1_sample();
void _mg1_process();
void _mg1_write_out(FILE* _outfile);

// ********************************************************
//   field mg1_output function prototypes
void _mg1_output_raw_initialise();

// ********************************************************
//   moment group 2 function prototypes
void _mg2_sample();
void _mg2_process();
void _mg2_write_out(FILE* _outfile);

// ********************************************************
//   field mg2_output function prototypes
void _mg2_output_raw_initialise();

// ********************************************************
// MAIN ROUTINE
// ********************************************************
int main(int argc, char **argv)
{
  MPI_Init(&argc, &argv);
  MPI_Comm_size(MPI_COMM_WORLD, &_size);
  MPI_Comm_rank(MPI_COMM_WORLD, &_rank);

  #ifdef __APPLE__
    #if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1080
  {
    IOPMAssertionID _powerAssertionID = 0;
    IOReturn __io_result = IOPMAssertionCreateWithDescription(
      kIOPMAssertionTypePreventUserIdleSystemSleep,
      CFSTR("XMDS simulation 'ce-vortice-TF' preventing user idle sleep"), // Assertion name
      NULL, // Assertion details
      NULL, // Human-readable reason
      NULL, // Localization bundle path
      (CFTimeInterval)0, // never timeout
      kIOPMAssertionTimeoutActionRelease,
      &_powerAssertionID
      );
    if (__io_result != kIOReturnSuccess) {
      _LOG(_WARNING_LOG_LEVEL, "Failed to disable user idle sleep\n");
    }
    // Note, this power assertion is automatically released when the process quits.
  }
    #endif
  #endif
  
    
  // *********** Parse the command line for arguments, and set  *********
  // *********** the appropriate global variables               *********
  
  int resp;
  std::map<string, string> mInputArgsAndValues;
  
  while (1) {
    static struct option long_options[] = 
      {
        {"help", no_argument, 0, 'h'},
        {"mu", required_argument, 0, 'm'},
        {"g", required_argument, 0, 'g'},
        {"lamb", required_argument, 0, 'l'},
        {"R", required_argument, 0, 'R'},
        {"Z", required_argument, 0, 'Z'},
        {"X", required_argument, 0, 'X'},
        {"A", required_argument, 0, 'A'},
        {NULL, 0, 0, 0}
      };
    
    int option_index = 0;
  
    resp = getopt_long(argc, argv, "hm:g:l:R:Z:X:A:", long_options, &option_index);
    
    if (resp == -1)
      break;
  
    switch (resp) {
      case '?':
        // An unknown option was passed. Show allowed options and exit. 
        _print_usage(); // This causes the simulation to exit
  
      case 'h':
        _print_usage(); // This causes the simulation to exit
      
      case 'm':
        mu = strtod(optarg, NULL);
        break;
      
      case 'g':
        g = strtod(optarg, NULL);
        break;
      
      case 'l':
        lamb = strtod(optarg, NULL);
        break;
      
      case 'R':
        R = strtod(optarg, NULL);
        break;
      
      case 'Z':
        Z = strtod(optarg, NULL);
        break;
      
      case 'X':
        X = strtod(optarg, NULL);
        break;
      
      case 'A':
        A = strtod(optarg, NULL);
        break;
        
      default:
        _LOG(_ERROR_LOG_LEVEL, "Internal error in processing arguments.\n");
    }
  }
  
  
  if (optind < argc)
    _print_usage(); // This causes the simulation to exit.
  
  // ******** Argument post-processing code *******
  // **********************************************
  
    // First work out the local lattice and offset for the geometry
    ptrdiff_t _sizes[3];
    fftw_mpi_init();
    _sizes[0] = _lattice_r; _sizes[1] = _lattice_z;
    fftw_mpi_local_size_many_transposed(
      2, _sizes, 1, _block_size_r, _block_size_z, MPI_COMM_WORLD,
      &_local_unswapped_lattice_r, &_local_unswapped_offset_r,
      &_local_swapped_lattice_z, &_local_swapped_offset_z
    );
    
    if (_rank == 0) {
      _block_size_r = _local_unswapped_lattice_r;
      _block_size_z = _local_swapped_lattice_z;
    }
    MPI_Bcast(&_block_size_r, sizeof(ptrdiff_t), MPI_BYTE, 0, MPI_COMM_WORLD);
    MPI_Bcast(&_block_size_z, sizeof(ptrdiff_t), MPI_BYTE, 0, MPI_COMM_WORLD);
    
    _sizes[0] = _lattice_r; _sizes[1] = _lattice_kz;
    fftw_mpi_local_size_many_transposed(
      2, _sizes, 1, _block_size_r, _block_size_kz, MPI_COMM_WORLD,
      &_local_unswapped_lattice_r, &_local_unswapped_offset_r,
      &_local_swapped_lattice_kz, &_local_swapped_offset_kz
    );
    
    if (_rank == 0) {
      _block_size_r = _local_unswapped_lattice_r;
      _block_size_kz = _local_swapped_lattice_kz;
    }
    MPI_Bcast(&_block_size_r, sizeof(ptrdiff_t), MPI_BYTE, 0, MPI_COMM_WORLD);
    MPI_Bcast(&_block_size_kz, sizeof(ptrdiff_t), MPI_BYTE, 0, MPI_COMM_WORLD);
    
    _sizes[0] = _lattice_kr; _sizes[1] = _lattice_z;
    fftw_mpi_local_size_many_transposed(
      2, _sizes, 1, _block_size_kr, _block_size_z, MPI_COMM_WORLD,
      &_local_unswapped_lattice_kr, &_local_unswapped_offset_kr,
      &_local_swapped_lattice_z, &_local_swapped_offset_z
    );
    
    if (_rank == 0) {
      _block_size_kr = _local_unswapped_lattice_kr;
      _block_size_z = _local_swapped_lattice_z;
    }
    MPI_Bcast(&_block_size_kr, sizeof(ptrdiff_t), MPI_BYTE, 0, MPI_COMM_WORLD);
    MPI_Bcast(&_block_size_z, sizeof(ptrdiff_t), MPI_BYTE, 0, MPI_COMM_WORLD);
    
    _sizes[0] = _lattice_kr; _sizes[1] = _lattice_kz;
    fftw_mpi_local_size_many_transposed(
      2, _sizes, 1, _block_size_kr, _block_size_kz, MPI_COMM_WORLD,
      &_local_unswapped_lattice_kr, &_local_unswapped_offset_kr,
      &_local_swapped_lattice_kz, &_local_swapped_offset_kz
    );
    
    if (_rank == 0) {
      _block_size_kr = _local_unswapped_lattice_kr;
      _block_size_kz = _local_swapped_lattice_kz;
    }
    MPI_Bcast(&_block_size_kr, sizeof(ptrdiff_t), MPI_BYTE, 0, MPI_COMM_WORLD);
    MPI_Bcast(&_block_size_kz, sizeof(ptrdiff_t), MPI_BYTE, 0, MPI_COMM_WORLD);
    
    
  
  _rz_segment1_rz_operators_operator0_result_alloc_size = MAX(_rz_segment1_rz_operators_operator0_result_alloc_size, (_lattice_r * _local_swapped_lattice_z) * _rz_segment1_rz_operators_operator0_result_ncomponents);
  _rz_segment1_rz_operators_operator0_result_alloc_size = MAX(_rz_segment1_rz_operators_operator0_result_alloc_size, (_lattice_kz * _local_unswapped_lattice_kr) * _rz_segment1_rz_operators_operator0_result_ncomponents);
  _rz_segment1_rz_operators_operator0_field_alloc_size = MAX(_rz_segment1_rz_operators_operator0_field_alloc_size, (_lattice_kz * _local_unswapped_lattice_kr) * _rz_segment1_rz_operators_operator0_field_ncomponents);
  _mg0_output_raw_alloc_size = MAX(_mg0_output_raw_alloc_size, (_mg0_output_lattice_t) * _mg0_output_raw_ncomponents);
  _rz_main_alloc_size = MAX(_rz_main_alloc_size, (_lattice_r * _local_swapped_lattice_z) * _rz_main_ncomponents);
  _rz_main_alloc_size = MAX(_rz_main_alloc_size, (_lattice_kz * _local_unswapped_lattice_kr) * _rz_main_ncomponents);
  _rz_init_alloc_size = MAX(_rz_init_alloc_size, (_lattice_r * _local_swapped_lattice_z) * _rz_init_ncomponents);
  _mg2_output_raw_alloc_size = MAX(_mg2_output_raw_alloc_size, (_mg2_output_lattice_t) * _mg2_output_raw_ncomponents);
  _dimensionless_normalisation_alloc_size = MAX(_dimensionless_normalisation_alloc_size, (1) * _dimensionless_normalisation_ncomponents);
  _mg1_output_raw_alloc_size = MAX(_mg1_output_raw_alloc_size, (_mg1_output_lattice_t) * _mg1_output_raw_ncomponents);
  ptrdiff_t _local_alloc_size, _tmp;
  _sizes[0] = _lattice_z;
  _sizes[1] = _lattice_kr;
  _local_alloc_size = fftw_mpi_local_size_many_transposed(
    2, _sizes,
    (ptrdiff_t)_rz_segment1_rz_operators_operator0_result_ncomponents * 2,
    _block_size_z, _block_size_kr,
    MPI_COMM_WORLD,
    &_tmp, &_tmp, &_tmp, &_tmp /* Local lattices and offsets were obtained above */
  );
  _rz_segment1_rz_operators_operator0_result_alloc_size = MAX(_rz_segment1_rz_operators_operator0_result_alloc_size, (_local_alloc_size+1) / 2);
  _rz_main_alloc_size = MAX(_rz_main_alloc_size, (_local_alloc_size+1) / 2);
  
  _sizes[0] = _lattice_z;
  _sizes[1] = _lattice_kr;
  _local_alloc_size = fftw_mpi_local_size_many_transposed(
    2, _sizes,
    (ptrdiff_t)_rz_main_ncomponents * 2,
    _block_size_z, _block_size_kr,
    MPI_COMM_WORLD,
    &_tmp, &_tmp, &_tmp, &_tmp /* Local lattices and offsets were obtained above */
  );
  _rz_segment1_rz_operators_operator0_result_alloc_size = MAX(_rz_segment1_rz_operators_operator0_result_alloc_size, (_local_alloc_size+1) / 2);
  _rz_main_alloc_size = MAX(_rz_main_alloc_size, (_local_alloc_size+1) / 2);
  
  _r = (real*) xmds_malloc(sizeof(real) * (_lattice_r+1));
  
  _kr = (real*) xmds_malloc(sizeof(real) * (_lattice_kr+1));
  
  _z = (real*) xmds_malloc(sizeof(real) * (_lattice_z+1));
  
  _kz = (real*) xmds_malloc(sizeof(real) * (_lattice_kz+1));
  
  _rz_init = (real*) xmds_malloc(sizeof(real) * MAX(_rz_init_alloc_size,1));
  _active_rz_init = _rz_init;
  
  
  _rz_main = (complex*) xmds_malloc(sizeof(complex) * MAX(_rz_main_alloc_size,1));
  _active_rz_main = _rz_main;
  
  _dimensionless_normalisation = (real*) xmds_malloc(sizeof(real) * MAX(_dimensionless_normalisation_alloc_size,1));
  _active_dimensionless_normalisation = _dimensionless_normalisation;
  _mg0_output_t = (real*) xmds_malloc(sizeof(real) * (_mg0_output_lattice_t+1));
  
  
  _mg0_output_raw = (real*) xmds_malloc(sizeof(real) * MAX(_mg0_output_raw_alloc_size,1));
  _active_mg0_output_raw = _mg0_output_raw;
  _mg1_output_t = (real*) xmds_malloc(sizeof(real) * (_mg1_output_lattice_t+1));
  
  
  _mg1_output_raw = (real*) xmds_malloc(sizeof(real) * MAX(_mg1_output_raw_alloc_size,1));
  _active_mg1_output_raw = _mg1_output_raw;
  _mg2_output_t = (real*) xmds_malloc(sizeof(real) * (_mg2_output_lattice_t+1));
  
  
  _mg2_output_raw = (real*) xmds_malloc(sizeof(real) * MAX(_mg2_output_raw_alloc_size,1));
  _active_mg2_output_raw = _mg2_output_raw;
  
  
  for (long _index_r = 0; _index_r < _lattice_r; _index_r++) {
    const real besselFactor = jn(2, _normbesseljzeros_r[_index_r] * _besseljnorm_r);
    const real r_max = 15;
    _r[_index_r] = _normbesseljzeros_r[_index_r] * r_max;
    _dr_array[_index_r] = 2.0 / (besselFactor * besselFactor * _besseljnorm_r * _besseljnorm_r) * r_max * r_max;
  }
  for (long _index_kr = 0; _index_kr < _lattice_kr; _index_kr++) {
    const real besselFactor = jn(2, _normbesseljzeros_r[_index_kr] * _besseljnorm_r);
    const real kr_max = (_besseljnorm_r/((real)15));
    _kr[_index_kr] = _normbesseljzeros_r[_index_kr] * kr_max;
    _dkr_array[_index_kr] = 2.0 / (besselFactor * besselFactor * _besseljnorm_r * _besseljnorm_r) * kr_max * kr_max;
  }
  for (long _index_r = 0; _index_r < _lattice_r; _index_r++) {
    const real besselFactor = jn(2, _normbesseljzeros_r[_index_r] * _besseljnorm_r);
    const real r_max = 15;
    _r[_index_r] = _normbesseljzeros_r[_index_r] * r_max;
    _dr_array[_index_r] = 2.0 / (besselFactor * besselFactor * _besseljnorm_r * _besseljnorm_r) * r_max * r_max;
  }
  for (long _index_kr = 0; _index_kr < _lattice_kr; _index_kr++) {
    const real besselFactor = jn(2, _normbesseljzeros_r[_index_kr] * _besseljnorm_r);
    const real kr_max = (_besseljnorm_r/((real)15));
    _kr[_index_kr] = _normbesseljzeros_r[_index_kr] * kr_max;
    _dkr_array[_index_kr] = 2.0 / (besselFactor * besselFactor * _besseljnorm_r * _besseljnorm_r) * kr_max * kr_max;
  }
  for (long _index_z = 0; _index_z < _lattice_z; _index_z++)
    _z[_index_z] = _min_z + _index_z*_dz;
  for (long _index_kz = 0; _index_kz < (_lattice_kz+1)/2; _index_kz++)
    _kz[_index_kz] = _index_kz*_dkz;
  for (long _index_kz = (_lattice_kz+1)/2; _index_kz < _lattice_kz; _index_kz++)
    _kz[_index_kz] = -(_lattice_kz - _index_kz) * _dkz;
  for (long _index_z = 0; _index_z < _lattice_z; _index_z++)
    _z[_index_z] = _min_z + _index_z*_dz;
  for (long _index_kz = 0; _index_kz < (_lattice_kz+1)/2; _index_kz++)
    _kz[_index_kz] = _index_kz*_dkz;
  for (long _index_kz = (_lattice_kz+1)/2; _index_kz < _lattice_kz; _index_kz++)
    _kz[_index_kz] = -(_lattice_kz - _index_kz) * _dkz;
  _active_mg0_output_raw = _mg0_output_raw;
  _mg0_output_raw_initialise();
  _active_mg1_output_raw = _mg1_output_raw;
  _mg1_output_raw_initialise();
  _active_mg2_output_raw = _mg2_output_raw;
  _mg2_output_raw_initialise();
  
  #if defined(CBLAS_VECLIB)
  // We are using MPI. If we let vecLib spawn threads then overall performance will suffer
    setenv("VECLIB_MAXIMUM_THREADS", "1", 1);
  #endif
  
  // load wisdom
  #if CFG_OSAPI == CFG_OSAPI_POSIX // Don't load wisdom on windows
  {
    char _hostName[256];
    gethostname(_hostName, 256);
    _hostName[255] = '\0'; // just in case
    
    string _pathToWisdom = getenv("HOME");
    _pathToWisdom += "/.xmds/wisdom/";
    
    string _wisdomFileName = _hostName;
    _wisdomFileName += ".wisdom";
    _wisdomFileName += ".fftw3_mpi";
    
    FILE *_fp = NULL;
    
    _fp = fopen(_pathToWisdom.c_str(), "r");
    if (_fp) {
      fclose(_fp);
    } else {
      int _result = mkdir((string(getenv("HOME")) + "/.xmds").c_str(), S_IRWXU);
      if (mkdir(_pathToWisdom.c_str(), S_IRWXU)) {
        // We failed to create the ~/.xmds/wisdom directory
        _LOG(_WARNING_LOG_LEVEL, "Warning: Cannot find enlightenment, the path to wisdom ~/.xmds/wisdom doesn't seem to exist and we couldn't create it.\n"
                                 "         I'll use the current path instead.\n");
        _pathToWisdom = ""; // present directory
      }
      
    }
    
    _fftwWisdomPath = _pathToWisdom + _wisdomFileName;
    
    FILE *_wisdomFile = NULL;
    if ( (_wisdomFile = fopen(_fftwWisdomPath.c_str(), "r")) != NULL) {
      _LOG(_SIMULATION_LOG_LEVEL, "Found enlightenment... (Importing wisdom)\n");
      fftw_import_wisdom_from_file(_wisdomFile);
      fclose(_wisdomFile);
    }
  }
  fftw_mpi_broadcast_wisdom(MPI_COMM_WORLD);
  #endif // POSIX
  
  _basis_transform_t *_basis_transform = NULL;
  ptrdiff_t _auxiliary_array_size = 0;
  ptrdiff_t _max_vector_size = 0;
  real* _max_vector_array = NULL;
  
  if (2 * _rz_segment1_rz_operators_operator0_result_alloc_size > _max_vector_size) {
    _max_vector_size = 2 * _rz_segment1_rz_operators_operator0_result_alloc_size;
    _max_vector_array = reinterpret_cast<real*>(_rz_segment1_rz_operators_operator0_result);
  }
  _basis_transform = &_rz_segment1_rz_operators_operator0_result_basis_map[_basis_pair(1, 0)];
  _basis_transform->_multiplier = _inverse_sqrt_2pi * _dz;
  _basis_transform->append(
    /* transform function */ _transform_0,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _local_swapped_lattice_z * _rz_segment1_rz_operators_operator0_result_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_1,
    /* forward? */ false,
    /* out-of-place? */ false,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _rz_segment1_rz_operators_operator0_result_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_2,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _local_unswapped_lattice_kr * _rz_segment1_rz_operators_operator0_result_ncomponents
  );
  _basis_transform->append(
    /* transform function */ _transform_3,
    /* forward? */ true,
    /* out-of-place? */ false,
    /* prefix lattice */ _local_unswapped_lattice_kr * _lattice_kz,
    /* postfix lattice*/ _rz_segment1_rz_operators_operator0_result_ncomponents * 2
  );
  
  _basis_transform = &_rz_segment1_rz_operators_operator0_result_basis_map[_basis_pair(0, 1)];
  _basis_transform->_multiplier = _inverse_sqrt_2pi * _dkz;
  _basis_transform->append(
    /* transform function */ _transform_3,
    /* forward? */ false,
    /* out-of-place? */ false,
    /* prefix lattice */ _local_unswapped_lattice_kr * _lattice_kz,
    /* postfix lattice */ _rz_segment1_rz_operators_operator0_result_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_2,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _local_unswapped_lattice_kr * _rz_segment1_rz_operators_operator0_result_ncomponents
  );
  _basis_transform->append(
    /* transform function */ _transform_1,
    /* forward? */ true,
    /* out-of-place? */ false,
    /* prefix lattice */ 1,
    /* postfix lattice */ _rz_segment1_rz_operators_operator0_result_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_0,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _local_swapped_lattice_z * _rz_segment1_rz_operators_operator0_result_ncomponents * 2
  );
  
  _auxiliary_array_size = MAX(_auxiliary_array_size, 2 * _rz_segment1_rz_operators_operator0_result_alloc_size); // vector 'segment1_rz_operators_operator0_result' needs an out-of-place transform
  
  if (2 * _rz_main_alloc_size > _max_vector_size) {
    _max_vector_size = 2 * _rz_main_alloc_size;
    _max_vector_array = reinterpret_cast<real*>(_rz_main);
  }
  _basis_transform = &_rz_main_basis_map[_basis_pair(1, 0)];
  _basis_transform->_multiplier = _inverse_sqrt_2pi * _dz;
  _basis_transform->append(
    /* transform function */ _transform_0,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _local_swapped_lattice_z * _rz_main_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_4,
    /* forward? */ false,
    /* out-of-place? */ false,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _rz_main_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_5,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _local_unswapped_lattice_kr * _rz_main_ncomponents
  );
  _basis_transform->append(
    /* transform function */ _transform_3,
    /* forward? */ true,
    /* out-of-place? */ false,
    /* prefix lattice */ _local_unswapped_lattice_kr * _lattice_kz,
    /* postfix lattice*/ _rz_main_ncomponents * 2
  );
  
  _basis_transform = &_rz_main_basis_map[_basis_pair(0, 1)];
  _basis_transform->_multiplier = _inverse_sqrt_2pi * _dkz;
  _basis_transform->append(
    /* transform function */ _transform_3,
    /* forward? */ false,
    /* out-of-place? */ false,
    /* prefix lattice */ _local_unswapped_lattice_kr * _lattice_kz,
    /* postfix lattice */ _rz_main_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_5,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _local_unswapped_lattice_kr * _rz_main_ncomponents
  );
  _basis_transform->append(
    /* transform function */ _transform_4,
    /* forward? */ true,
    /* out-of-place? */ false,
    /* prefix lattice */ 1,
    /* postfix lattice */ _rz_main_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_0,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _local_swapped_lattice_z * _rz_main_ncomponents * 2
  );
  
  _auxiliary_array_size = MAX(_auxiliary_array_size, 2 * _rz_main_alloc_size); // vector 'main' needs an out-of-place transform
  
  if (_auxiliary_array_size) {
    _auxiliary_array = (real*) xmds_malloc(sizeof(real) * _auxiliary_array_size);
  }
  
  bool _allocated_temporary_array = false;
  if (!_max_vector_array && _max_vector_size > 0) {
    _max_vector_array = (real*) xmds_malloc(sizeof(real) * _max_vector_size);
    _allocated_temporary_array = true;
  }
  
  // Make all geometry-dependent transformations prepare plans, etc.
  _transform_1(true, 1.0, _max_vector_array, _auxiliary_array, 1, _rz_segment1_rz_operators_operator0_result_ncomponents * 2);
  _transform_2(true, 1.0, _max_vector_array, _auxiliary_array, 1, _local_unswapped_lattice_kr * _rz_segment1_rz_operators_operator0_result_ncomponents);
  _transform_4(true, 1.0, _max_vector_array, _auxiliary_array, 1, _rz_main_ncomponents * 2);
  _transform_5(true, 1.0, _max_vector_array, _auxiliary_array, 1, _local_unswapped_lattice_kr * _rz_main_ncomponents);
  
  if (_allocated_temporary_array) {
    xmds_free(_max_vector_array);
  }
  
  // Get the time at which the simulation started
  timeval _tim;
  gettimeofday(&_tim, NULL);
  double _startTime = _tim.tv_sec + (_tim.tv_usec/1e6);
  
  /* Code that actually does stuff goes here */
  _segment0();
  
  
  _write_output();
  
  // Work out how long the simulation has run for
  gettimeofday(&_tim, NULL);
  double _endTime = _tim.tv_sec + (_tim.tv_usec/1e6);
  _LOG(_SIMULATION_LOG_LEVEL, "Time elapsed for simulation is: %.2f seconds\n", _endTime - _startTime);
  if (_auxiliary_array) {
    xmds_free(_auxiliary_array);
  }
  
  // Save wisdom
  #if CFG_OSAPI == CFG_OSAPI_POSIX
  fftw_mpi_gather_wisdom(MPI_COMM_WORLD);
  {
    FILE *_wisdomFile = NULL;
    if ( (_wisdomFile = fopen(_fftwWisdomPath.c_str(), "w")) != NULL) {
      fftw_export_wisdom_to_file(_wisdomFile);
      fclose(_wisdomFile);
    }
  }
  #endif // POSIX
  
  fftw_cleanup();
  
  // Bing!
  _LOG(_SIMULATION_LOG_LEVEL, "\a");
  
  xmds_free(_rz_init);
  _active_rz_init = _rz_init = NULL;
  
  
  xmds_free(_rz_main);
  _active_rz_main = _rz_main = NULL;
  
  xmds_free(_dimensionless_normalisation);
  _active_dimensionless_normalisation = _dimensionless_normalisation = NULL;
  
  xmds_free(_mg0_output_raw);
  _active_mg0_output_raw = _mg0_output_raw = NULL;
  
  xmds_free(_mg1_output_raw);
  _active_mg1_output_raw = _mg1_output_raw = NULL;
  
  xmds_free(_mg2_output_raw);
  _active_mg2_output_raw = _mg2_output_raw = NULL;
  
  
  MPI_Finalize();
  
  return 0;
}

// ********************************************************
// FUNCTION IMPLEMENTATIONS
// ********************************************************

// ********************************************************
//   Distributed MPI Simulation Driver function implementations
void _segment0()
{
  t = 0.0;
  
  _mg0_output_raw_initialise();
  _mg1_output_raw_initialise();
  _mg2_output_raw_initialise();
  _active_rz_init = _rz_init;
  _rz_init_initialise();
  _active_rz_main = _rz_main;
  _rz_main_initialise();
  _mg0_output_index_t = 0;
  _mg1_output_index_t = 0;
  _mg2_output_index_t = 0;
  _mg0_sample();
  _mg1_sample();
  _mg2_sample();
  _segment1();
  
  _mg0_process();
  _mg1_process();
  _mg2_process();
}


// ********************************************************
//   Transform Multiplexer function implementations
// r <---> kr transform
void _transform_0(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
{
  if (_prefix_lattice <= 0 || _postfix_lattice <= 0) return;
  static bool _initialised = false;
  static real *_mmt_matrix_forward = NULL;
  static real *_mmt_matrix_backward = NULL;
  ptrdiff_t innerLoopSize = _postfix_lattice;
  real* const __restrict__ source_data = reinterpret_cast<real* const>(_data_in);
  real* const __restrict__ dest_data = reinterpret_cast<real* const>(_data_out);
  
  if (!_initialised) {
    _LOG(_SIMULATION_LOG_LEVEL, "Building matrices for r <---> kr transform...");
    
    _mmt_matrix_forward  = (real *)xmds_malloc(sizeof(real) * _lattice_r * _lattice_kr);
    _mmt_matrix_backward = (real *)xmds_malloc(sizeof(real) * _lattice_kr * _lattice_r);
    for (long _i0 = 0; _i0 < _lattice_r; _i0++) {
      for (long _i1 = 0; _i1 < _lattice_kr; _i1++) {
        const real besselFactor = j1(_normbesseljzeros_r[_i0] * _normbesseljzeros_r[_i1] * _besseljnorm_r);
        _mmt_matrix_forward [_i1 * _lattice_r + _i0] = \
          besselFactor * _dr_array[_i0];
        _mmt_matrix_backward[_i0 * _lattice_kr + _i1] = \
          besselFactor * _dkr_array[_i1];
      }
    }
    
    _LOG(_SIMULATION_LOG_LEVEL, " done.\n");
    _initialised = true;
  }
  
  if (_forward) {
    for (long _i0 = 0; _i0 < _prefix_lattice; _i0++) {
      const real alpha = 1.0;
      const real beta = 0.0;
      cblas_dgemm(
        CblasRowMajor, CblasNoTrans, CblasNoTrans,
        _lattice_kr,
        /* nelem */ innerLoopSize,
        _lattice_r,
        /* alpha */ alpha,
        /* A */ _mmt_matrix_forward, _lattice_r,
        /* B */ source_data + _i0 * innerLoopSize * _lattice_r,
                innerLoopSize,
        /* beta */ beta,
        /* C */ dest_data + _i0 * innerLoopSize * _lattice_kr,
        innerLoopSize
      );
    }
  } else {
    for (long _i0 = 0; _i0 < _prefix_lattice; _i0++) {
      const real alpha = 1.0;
      const real beta = 0.0;
      cblas_dgemm(
        CblasRowMajor, CblasNoTrans, CblasNoTrans,
        _lattice_r,
        /* nelem */ innerLoopSize,
        _lattice_kr,
        /* alpha */ alpha,
        /* A */ _mmt_matrix_backward, _lattice_kr,
        /* B */ source_data + _i0 * innerLoopSize * _lattice_kr,
                innerLoopSize,
        /* beta */ beta,
        /* C */ dest_data + _i0 * innerLoopSize * _lattice_r,
        innerLoopSize
      );
    }
  }
}


// (z, distributed kr) <---> (kr, distributed z) transform
void _transform_1(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
{
  if (_prefix_lattice <= 0 || _postfix_lattice <= 0) return;
  // _prefix_lattice should be 1
  // _postfix_lattice should be 4
  static fftw_plan _fftw_forward_plan = NULL;
  static fftw_plan _fftw_backward_plan = NULL;
  
  if (!_fftw_forward_plan) {
    _LOG(_SIMULATION_LOG_LEVEL, "Planning for (z, distributed kr) <---> (kr, distributed z) transform...");
    
    _fftw_forward_plan = fftw_mpi_plan_many_transpose(
      _lattice_kr, _lattice_z,
      _postfix_lattice, _block_size_kr, _block_size_z,
      reinterpret_cast<real*>(_data_in),
      reinterpret_cast<real*>(_data_in),
      MPI_COMM_WORLD, FFTW_PATIENT | FFTW_MPI_TRANSPOSED_IN | FFTW_MPI_TRANSPOSED_OUT
    );
    
    if (!_fftw_forward_plan)
      _LOG(_ERROR_LOG_LEVEL, "(%s: %i) Unable to create forward mpi transform plan.\n", __FILE__, __LINE__);
    
    _fftw_backward_plan = fftw_mpi_plan_many_transpose(
      _lattice_z, _lattice_kr,
      _postfix_lattice, _block_size_z, _block_size_kr,
      reinterpret_cast<real*>(_data_in),
      reinterpret_cast<real*>(_data_in),
      MPI_COMM_WORLD, FFTW_PATIENT | FFTW_MPI_TRANSPOSED_IN | FFTW_MPI_TRANSPOSED_OUT
    );
    
    if (!_fftw_backward_plan)
      _LOG(_ERROR_LOG_LEVEL, "(%s: %i) Unable to create backward mpi transform plan.\n", __FILE__, __LINE__);
    
    // Save wisdom
    #if CFG_OSAPI == CFG_OSAPI_POSIX
    fftw_mpi_gather_wisdom(MPI_COMM_WORLD);
    {
      FILE *_wisdomFile = NULL;
      if ( (_wisdomFile = fopen(_fftwWisdomPath.c_str(), "w")) != NULL) {
        fftw_export_wisdom_to_file(_wisdomFile);
        fclose(_wisdomFile);
      }
    }
    #endif // POSIX
    
    _LOG(_SIMULATION_LOG_LEVEL, " done.\n");
  }
  
  if (_forward) {
    fftw_execute_r2r(
      _fftw_forward_plan,
      reinterpret_cast<real*>(_data_in),
      reinterpret_cast<real*>(_data_in)
    );
  } else {
    fftw_execute_r2r(
      _fftw_backward_plan,
      reinterpret_cast<real*>(_data_in),
      reinterpret_cast<real*>(_data_in)
    );
  }
}


// z <---> kz transform
void _transform_2(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
{
  if (_prefix_lattice <= 0 || _postfix_lattice <= 0) return;
  // _prefix_lattice should be 1
  // _postfix_lattice should be 2 * _local_unswapped_lattice_kr
  static fftw_plan _fftw_forward_plan = NULL;
  static fftw_plan _fftw_backward_plan = NULL;
  
  if (!_fftw_forward_plan) {
    _LOG(_SIMULATION_LOG_LEVEL, "Planning for z <---> kz transform...");
    
    fftw_iodim _transform_sizes[1], _loop_sizes[2];
    fftw_iodim *_iodim_ptr = NULL;
    
    int _transform_sizes_index = 0, _loop_sizes_index = 0;
    
    if (_prefix_lattice > 1) {
      _iodim_ptr = &_loop_sizes[_loop_sizes_index++];
      _iodim_ptr->n = _prefix_lattice;
      _iodim_ptr->is = _iodim_ptr->os = _postfix_lattice * _lattice_z;
    }
    if (_postfix_lattice > 1) {
      _iodim_ptr = &_loop_sizes[_loop_sizes_index++];
      _iodim_ptr->n = _postfix_lattice;
      _iodim_ptr->is = _iodim_ptr->os = 1;
    }
    _iodim_ptr = &_transform_sizes[_transform_sizes_index++];
    _iodim_ptr->n = _lattice_z;
    _iodim_ptr->is = _iodim_ptr->os = _postfix_lattice;
    
    
    _fftw_forward_plan = fftw_plan_guru_dft(
      _transform_sizes_index, _transform_sizes,
      _loop_sizes_index, _loop_sizes,
      reinterpret_cast<fftw_complex*>(_data_in), reinterpret_cast<fftw_complex*>(_data_out),
      FFTW_FORWARD, FFTW_PATIENT | FFTW_DESTROY_INPUT
    );
    if (!_fftw_forward_plan)
      _LOG(_ERROR_LOG_LEVEL, "(%s: %i) Unable to create forward dft plan.\n", __FILE__, __LINE__);
    
    _fftw_backward_plan = fftw_plan_guru_dft(
      _transform_sizes_index, _transform_sizes,
      _loop_sizes_index, _loop_sizes,
      reinterpret_cast<fftw_complex*>(_data_in), reinterpret_cast<fftw_complex*>(_data_out),
      FFTW_BACKWARD, FFTW_PATIENT | FFTW_DESTROY_INPUT
    );
    if (!_fftw_backward_plan)
      _LOG(_ERROR_LOG_LEVEL, "(%s: %i) Unable to create backward dft plan.\n", __FILE__, __LINE__);
    
    
    _LOG(_SIMULATION_LOG_LEVEL, " done.\n");
  }
  
  if (_forward) {
    fftw_execute_dft(
      _fftw_forward_plan,
      reinterpret_cast<fftw_complex*>(_data_in),
      reinterpret_cast<fftw_complex*>(_data_out)
    );
  } else {
    fftw_execute_dft(
      _fftw_backward_plan,
      reinterpret_cast<fftw_complex*>(_data_in),
      reinterpret_cast<fftw_complex*>(_data_out)
    );
  }
}


// In-place multiply
void _transform_3(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
{
  if (_prefix_lattice <= 0 || _postfix_lattice <= 0) return;
  #pragma ivdep
  for (long _i0 = 0; _i0 < _prefix_lattice * _postfix_lattice; _i0++) {
    _data_in[_i0] *= _multiplier;
  }
}


// (z, distributed kr) <---> (kr, distributed z) transform
void _transform_4(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
{
  if (_prefix_lattice <= 0 || _postfix_lattice <= 0) return;
  // _prefix_lattice should be 1
  // _postfix_lattice should be 2
  static fftw_plan _fftw_forward_plan = NULL;
  static fftw_plan _fftw_backward_plan = NULL;
  
  if (!_fftw_forward_plan) {
    _LOG(_SIMULATION_LOG_LEVEL, "Planning for (z, distributed kr) <---> (kr, distributed z) transform...");
    
    _fftw_forward_plan = fftw_mpi_plan_many_transpose(
      _lattice_kr, _lattice_z,
      _postfix_lattice, _block_size_kr, _block_size_z,
      reinterpret_cast<real*>(_data_in),
      reinterpret_cast<real*>(_data_in),
      MPI_COMM_WORLD, FFTW_PATIENT | FFTW_MPI_TRANSPOSED_IN | FFTW_MPI_TRANSPOSED_OUT
    );
    
    if (!_fftw_forward_plan)
      _LOG(_ERROR_LOG_LEVEL, "(%s: %i) Unable to create forward mpi transform plan.\n", __FILE__, __LINE__);
    
    _fftw_backward_plan = fftw_mpi_plan_many_transpose(
      _lattice_z, _lattice_kr,
      _postfix_lattice, _block_size_z, _block_size_kr,
      reinterpret_cast<real*>(_data_in),
      reinterpret_cast<real*>(_data_in),
      MPI_COMM_WORLD, FFTW_PATIENT | FFTW_MPI_TRANSPOSED_IN | FFTW_MPI_TRANSPOSED_OUT
    );
    
    if (!_fftw_backward_plan)
      _LOG(_ERROR_LOG_LEVEL, "(%s: %i) Unable to create backward mpi transform plan.\n", __FILE__, __LINE__);
    
    // Save wisdom
    #if CFG_OSAPI == CFG_OSAPI_POSIX
    fftw_mpi_gather_wisdom(MPI_COMM_WORLD);
    {
      FILE *_wisdomFile = NULL;
      if ( (_wisdomFile = fopen(_fftwWisdomPath.c_str(), "w")) != NULL) {
        fftw_export_wisdom_to_file(_wisdomFile);
        fclose(_wisdomFile);
      }
    }
    #endif // POSIX
    
    _LOG(_SIMULATION_LOG_LEVEL, " done.\n");
  }
  
  if (_forward) {
    fftw_execute_r2r(
      _fftw_forward_plan,
      reinterpret_cast<real*>(_data_in),
      reinterpret_cast<real*>(_data_in)
    );
  } else {
    fftw_execute_r2r(
      _fftw_backward_plan,
      reinterpret_cast<real*>(_data_in),
      reinterpret_cast<real*>(_data_in)
    );
  }
}


// z <---> kz transform
void _transform_5(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
{
  if (_prefix_lattice <= 0 || _postfix_lattice <= 0) return;
  // _prefix_lattice should be 1
  // _postfix_lattice should be 1 * _local_unswapped_lattice_kr
  static fftw_plan _fftw_forward_plan = NULL;
  static fftw_plan _fftw_backward_plan = NULL;
  
  if (!_fftw_forward_plan) {
    _LOG(_SIMULATION_LOG_LEVEL, "Planning for z <---> kz transform...");
    
    fftw_iodim _transform_sizes[1], _loop_sizes[2];
    fftw_iodim *_iodim_ptr = NULL;
    
    int _transform_sizes_index = 0, _loop_sizes_index = 0;
    
    if (_prefix_lattice > 1) {
      _iodim_ptr = &_loop_sizes[_loop_sizes_index++];
      _iodim_ptr->n = _prefix_lattice;
      _iodim_ptr->is = _iodim_ptr->os = _postfix_lattice * _lattice_z;
    }
    if (_postfix_lattice > 1) {
      _iodim_ptr = &_loop_sizes[_loop_sizes_index++];
      _iodim_ptr->n = _postfix_lattice;
      _iodim_ptr->is = _iodim_ptr->os = 1;
    }
    _iodim_ptr = &_transform_sizes[_transform_sizes_index++];
    _iodim_ptr->n = _lattice_z;
    _iodim_ptr->is = _iodim_ptr->os = _postfix_lattice;
    
    
    _fftw_forward_plan = fftw_plan_guru_dft(
      _transform_sizes_index, _transform_sizes,
      _loop_sizes_index, _loop_sizes,
      reinterpret_cast<fftw_complex*>(_data_in), reinterpret_cast<fftw_complex*>(_data_out),
      FFTW_FORWARD, FFTW_PATIENT | FFTW_DESTROY_INPUT
    );
    if (!_fftw_forward_plan)
      _LOG(_ERROR_LOG_LEVEL, "(%s: %i) Unable to create forward dft plan.\n", __FILE__, __LINE__);
    
    _fftw_backward_plan = fftw_plan_guru_dft(
      _transform_sizes_index, _transform_sizes,
      _loop_sizes_index, _loop_sizes,
      reinterpret_cast<fftw_complex*>(_data_in), reinterpret_cast<fftw_complex*>(_data_out),
      FFTW_BACKWARD, FFTW_PATIENT | FFTW_DESTROY_INPUT
    );
    if (!_fftw_backward_plan)
      _LOG(_ERROR_LOG_LEVEL, "(%s: %i) Unable to create backward dft plan.\n", __FILE__, __LINE__);
    
    
    _LOG(_SIMULATION_LOG_LEVEL, " done.\n");
  }
  
  if (_forward) {
    fftw_execute_dft(
      _fftw_forward_plan,
      reinterpret_cast<fftw_complex*>(_data_in),
      reinterpret_cast<fftw_complex*>(_data_out)
    );
  } else {
    fftw_execute_dft(
      _fftw_backward_plan,
      reinterpret_cast<fftw_complex*>(_data_in),
      reinterpret_cast<fftw_complex*>(_data_out)
    );
  }
}

// ********************************************************
//   Command line argument processing function implementations
void _print_usage()
{
  // This function does not return.
  _LOG(_NO_ERROR_TERMINATE_LOG_LEVEL, "\n\nUsage: ce-vortice-TF --mu <real> --g <real> --lamb <real> --R <real> --Z <real> --X <real> --A <real>\n\n"
                         "Details:\n"
                         "Option\t\tType\t\tDefault value\n"
                         "-m,  --mu\treal \t\t20.74\n"
                         "-g,  --g\treal \t\t800.0\n"
                         "-l,  --lamb\treal \t\t0.9\n"
                         "-R,  --R\treal \t\t6.4219\n"
                         "-Z,  --Z\treal \t\t7.10582\n"
                         "-X,  --X\treal \t\t0.255784\n"
                         "-A,  --A\treal \t\t0.0455999\n"
                         );
  // _LOG terminates the simulation.
}

// ********************************************************
//   field rz function implementations
// initialisation for vector init
void _rz_init_initialise()
{
  
  long _rz_init_index_pointer = 0;
  #define DI _active_rz_init[_rz_init_index_pointer + 0]
  #define r _r[_index_r + 0]
  #define dr (_dr_array[_index_r + 0] * (1.0))
  
  for (long _index_r = 0; _index_r < _lattice_r; _index_r++) {
    #define z _z[_index_z + _local_swapped_offset_z]
    #define dz (_dz * (1.0))
    
    for (long _index_z = 0; _index_z < _local_swapped_lattice_z; _index_z++) {
      // The purpose of the following define is to give a (somewhat helpful) compile-time error
      // if the user has attempted to use the propagation dimension variable in the initialisation
      // block of a <vector> element. If they're trying to do this, what they really want is a 
      // <computed_vector> instead.
      #define t Dont_use_propagation_dimension_t_in_vector_element_CDATA_block___Use_a_computed_vector_instead
      
      // ********** Initialisation code ***************
      #line 37 "vortex-ce-TF.xmds"
      
      if ((1 - r*r/(R*R) - z*z/(Z*Z)) > 0) {
         DI = A*sqrt(r*r/(r*r+X*X))*sqrt(1 - r*r/(R*R) - z*z/(Z*Z));
         // This will be automatically normalised later
       } else {
         DI = 0.0;
       }
      #line 1579 "ce-vortice-TF.cc"
      // **********************************************
      #undef t
      
      // Increment index pointers for vectors in field rz (or having the same dimensions)
      _rz_init_index_pointer += 1 * _rz_init_ncomponents;
      
    }
    #undef z
    #undef dz
  }
  #undef r
  #undef dr
  #undef DI
}

// initialisation for vector main
void _rz_main_initialise()
{
  
  long _rz_init_index_pointer = 0;
  #define DI _active_rz_init[_rz_init_index_pointer + 0]
  long _rz_main_index_pointer = 0;
  #define D _active_rz_main[_rz_main_index_pointer + 0]
  #define r _r[_index_r + 0]
  #define dr (_dr_array[_index_r + 0] * (1.0))
  
  for (long _index_r = 0; _index_r < _lattice_r; _index_r++) {
    #define z _z[_index_z + _local_swapped_offset_z]
    #define dz (_dz * (1.0))
    
    for (long _index_z = 0; _index_z < _local_swapped_lattice_z; _index_z++) {
      // The purpose of the following define is to give a (somewhat helpful) compile-time error
      // if the user has attempted to use the propagation dimension variable in the initialisation
      // block of a <vector> element. If they're trying to do this, what they really want is a 
      // <computed_vector> instead.
      #define t Dont_use_propagation_dimension_t_in_vector_element_CDATA_block___Use_a_computed_vector_instead
      
      // ********** Initialisation code ***************
      #line 53 "vortex-ce-TF.xmds"
      
      D = DI;
      #line 1621 "ce-vortice-TF.cc"
      // **********************************************
      #undef t
      
      // Increment index pointers for vectors in field rz (or having the same dimensions)
      _rz_init_index_pointer += 1 * _rz_init_ncomponents;
      _rz_main_index_pointer += 1 * _rz_main_ncomponents;
      
    }
    #undef z
    #undef dz
  }
  #undef r
  #undef dr
  #undef DI
  #undef D
  
  _rz_main_basis = 1;
}


void _rz_main_basis_transform(ptrdiff_t new_basis)
{
  if (_rz_main_basis == new_basis)
    return;
  
  if (_rz_main_basis == -1) {
    _LOG(
      _ERROR_LOG_LEVEL,
      "Error: Attempted to transform the vector 'rz_main' to basis %s, but the vector doesn't have a basis specified yet!\n"
      "       Please report this error to xmds-devel@lists.sourceforge.net\n",
      _basis_identifiers[new_basis]
      );
  }
  
  if (_rz_main_basis_map.count(_basis_pair(_rz_main_basis, new_basis)) == 0) {
    _LOG(
      _ERROR_LOG_LEVEL,
      "Error: We should have information about how to do every needed transform, but it seems we don't for this transform.\n"
      "       The transform is for the vector 'rz_main' from basis %s to basis %s.\n",
      _basis_identifiers[_rz_main_basis], _basis_identifiers[new_basis]
    );
  }
  _basis_transform_t &_t = _rz_main_basis_map[_basis_pair(_rz_main_basis, new_basis)];
  if (_t._transform_steps.size() == 0) {
    _LOG(_ERROR_LOG_LEVEL, "Error: It looks like we tried to create plans for this transform, but failed.\n"
                           "       The transform was for the vector 'rz_main' from basis %s to basis %s.\n",
                           _basis_identifiers[_rz_main_basis], _basis_identifiers[new_basis]);
  }
  real *_source_data = reinterpret_cast<real*>(_active_rz_main);
  real *_dest_data = _auxiliary_array;
  for (vector<_transform_step>::iterator _it = _t._transform_steps.begin(); _it != _t._transform_steps.end(); ++_it) {
    _it->_func(_it->_forward, _t._multiplier, _source_data, _dest_data, _it->_prefix_lattice, _it->_postfix_lattice);
    if (_it->_out_of_place) {
      real *_temp = _source_data;
      _source_data = _dest_data;
      _dest_data = _temp;
    }
  }
  _rz_main_basis = new_basis;
}

// ********************************************************
//   field dimensionless function implementations
void _dimensionless_normalisation_evaluate()
{
  _active_dimensionless_normalisation = _dimensionless_normalisation;
  _dimensionless_normalisation_initialise();
  
  _rz_main_basis_transform(1); // (r, distributed z)
  
  long _dimensionless_normalisation_index_pointer = 0;
  real Ncalc;
  long _rz_main_index_pointer = 0;
  #define D _active_rz_main[_rz_main_index_pointer + 0]
  #define r _r[_index_r + 0]
  #define dr (_dr_array[_index_r + 0] * (1.0))
  
  for (long _index_r = 0; _index_r < _lattice_r; _index_r++) {
    #define z _z[_index_z + _local_swapped_offset_z]
    #define dz (_dz * (1.0))
    
    for (long _index_z = 0; _index_z < _local_swapped_lattice_z; _index_z++) {
      // ************* Evaluation code ****************
      #line 64 "vortex-ce-TF.xmds"
      
      // Calculate the current normalisation of the wave function.
      Ncalc = 2.0*M_PI*mod2(D);
      #line 1709 "ce-vortice-TF.cc"
      // **********************************************
      
      _active_dimensionless_normalisation[_dimensionless_normalisation_index_pointer + 0] += Ncalc * dr * dz;
      // Increment index pointers for vectors in field rz (or having the same dimensions)
      _rz_main_index_pointer += 1 * _rz_main_ncomponents;
      
    }
    #undef z
    #undef dz
  }
  #undef r
  #undef dr
  #undef D
  MPI_Allreduce(MPI_IN_PLACE, _active_dimensionless_normalisation, (1) * _dimensionless_normalisation_ncomponents,
                MPI_REAL, MPI_SUM, MPI_COMM_WORLD);
}


// initialisation for computed vector normalisation
void _dimensionless_normalisation_initialise()
{
  // Because we're integrating over dimensions, we need to set the vector to zero.
  bzero(_active_dimensionless_normalisation, sizeof(real) * _dimensionless_normalisation_alloc_size);
}

// ********************************************************
//   segment 1 (RK45 adaptive-step integrator) function implementations
inline void _segment1_calculate_delta_a(real _step)
{
  
  // EX transverse derivative operator for field rz
  _segment1_rz_operators_evaluate_operator0();
  
  // Delta A propagation operator for field rz
  _segment1_rz_operators_evaluate_operator1(_step);
  
}


inline void _segment1_calculate_nonconstant_ip_fields(real _step, int _exponent, int _arrayIndex)
{
}


void _segment1()
{
  real _step = 100.0/(real)100000;
  real _old_step = _step;
  real _min_step = _step;
  real _max_step = _step;
  long _attempted_steps = 0;
  long _unsuccessful_steps = 0;
  
  real _tolerance = 1e-05;
  
  real _error, _last_norm_error = 1.0;
  real _segment1_rz_main_error;
  
  bool _discard = false;
  bool _break_next = false;
  
  bool _next_sample_flag[5];
  for (long _i0 = 0; _i0 < 5; _i0++)
    _next_sample_flag[_i0] = false;
  
  long _next_sample_counter[3];
  for (long _i0 = 0; _i0 < 3; _i0++)
    _next_sample_counter[_i0] = 1;
  
  real _t_local = 0.0;
  
  real _t_break_next = _segment1_setup_sampling(_next_sample_flag, _next_sample_counter);
  
  if ( (_t_local + _step)*(1.0 + _EPSILON) >= _t_break_next) {
    _break_next = true;
    _step = _t_break_next - _t_local;
  }
  
  
  _rz_segment1_rz_operators_operator0_field = (complex*) xmds_malloc(sizeof(complex) * MAX(_rz_segment1_rz_operators_operator0_field_alloc_size,1));
  _active_rz_segment1_rz_operators_operator0_field = _rz_segment1_rz_operators_operator0_field;
  
  
  _rz_segment1_rz_operators_operator0_result = (complex*) xmds_malloc(sizeof(complex) * MAX(_rz_segment1_rz_operators_operator0_result_alloc_size,1));
  _active_rz_segment1_rz_operators_operator0_result = _rz_segment1_rz_operators_operator0_result;
  _segment1_akfield_rz_main = (complex*) xmds_malloc(sizeof(complex) * MAX(_rz_main_alloc_size,1));
  _segment1_aifield_rz_main = (complex*) xmds_malloc(sizeof(complex) * MAX(_rz_main_alloc_size,1));
  _segment1_ajfield_rz_main = (complex*) xmds_malloc(sizeof(complex) * MAX(_rz_main_alloc_size,1));
  _segment1_alfield_rz_main = (complex*) xmds_malloc(sizeof(complex) * MAX(_rz_main_alloc_size,1));
  _segment1_checkfield_rz_main = (complex*) xmds_malloc(sizeof(complex) * MAX(_rz_main_alloc_size,1));
  _segment1_rz_operators_calculate_operator0_field();
  complex* _akfield_rz_main = _segment1_akfield_rz_main;
  complex* _aifield_rz_main = _segment1_aifield_rz_main;
  complex* _ajfield_rz_main = _segment1_ajfield_rz_main;
  complex* _alfield_rz_main = _segment1_alfield_rz_main;
  complex* _checkfield_rz_main = _segment1_checkfield_rz_main;
  
  
  // Cash-Karp coefficients
  real _a_raw[7];
  real _a[7];
  real _b[7][7];
  real _c[7];
  real _cs[7];
  // linear combinations for the (k_i)s
  real _d[4];
  real _e[5];
  real _f[6];
  real _g[7];
  
  _a_raw[0]=0.0;
  _a_raw[1]=0.0;
  _a_raw[2]=1.0/5;
  _a_raw[3]=3.0/10;
  _a_raw[4]=3.0/5;
  _a_raw[5]=1.0;
  _a_raw[6]=7.0/8.0;
  
  _a[0]=0.0;
  _a[1]=0.0;
  for(long _i0 = 2; _i0 < 7; _i0++)
    _a[_i0] = _a_raw[_i0] - _a_raw[_i0-1];
  
  _b[2][1]=1.0/5;
  _b[3][1]=3.0/40;
  _b[3][2]=9.0/40;
  _b[4][1]=3.0/10;
  _b[4][2]=-9.0/10;
  _b[4][3]=6.0/5;
  _b[5][1]=-11.0/54;
  _b[5][2]=5.0/2;
  _b[5][3]=-70.0/27;
  _b[5][4]=35.0/27;
  _b[6][1]=1631.0/55296;
  _b[6][2]=175.0/512;
  _b[6][3]=575.0/13824;
  _b[6][4]=44275.0/110592;
  _b[6][5]=253.0/4096;
  
  _c[0]=0.0;
  _c[1]=37.0/378;
  _c[2]=0.0;
  _c[3]=250.0/621;
  _c[4]=125.0/594;
  _c[5]=0.0;
  _c[6]=512.0/1771;
  
  _cs[0]=0.0;
  _cs[1]=2825.0/27648;
  _cs[2]=0.0;
  _cs[3]=18575.0/48384;
  _cs[4]=13525.0/55296;
  _cs[5]=277.0/14336;
  _cs[6]=1.0/4;
  
  _d[0]=0.0;
  _d[1]=1.0-_b[3][1]/_c[1];
  _d[2]=_b[3][1]/_c[1];
  _d[3]=_b[3][2];
  
  _e[0]=0.0;
  _e[1]=1.0-_b[4][1]/_c[1];
  _e[2]=_b[4][1]/_c[1];
  _e[3]=_b[4][2];
  _e[4]=_b[4][3];
  
  _f[0]=0.0;
  _f[1]=1.0-_b[5][1]/_c[1];
  _f[2]=_b[5][1]/_c[1];
  _f[3]=_b[5][2];
  _f[4]=_b[5][3]-_b[5][1]/_c[1]*_c[3];
  _f[5]=_b[5][4]-_b[5][1]/_c[1]*_c[4];
  
  real _den=_c[1]*_cs[4]-_cs[1]*_c[4];
  _g[0]=0.0;
  _g[1]=( _b[6][4]*(_cs[1]-_c[1]) + _b[6][1]*(_c[4]-_cs[4]) )/_den + 1.0;
  _g[2]=  _b[6][2];
  _g[3]=( _b[6][4]*(_cs[1]*_c[3] - _c[1]*_cs[3]) + _b[6][1]*(_cs[3]*_c[4] - _c[3]*_cs[4]) )/_den + _b[6][3];
  _g[4]=( _b[6][1]*_cs[4]-_b[6][4]*_cs[1] )/_den;
  _g[5]=  _b[6][5] + _cs[5]*( _b[6][1]*_c[4]-_b[6][4]*_c[1] )/_den;
  _g[6]=( -_b[6][1]*_c[4]+_b[6][4]*_c[1] )/_den;
  
  do {
    
    do {
      
      _rz_main_basis_transform(1); // (r, distributed z)
      
      // a_k = y1
      memcpy(_akfield_rz_main, _rz_main, sizeof(complex) * _rz_main_alloc_size);
      
      _segment1_calculate_nonconstant_ip_fields(_step, 1, 0);
      
      // a_i = D(a_2*dt)[y1]
      _segment1_ip_evolve(1);
      _rz_main_basis_transform(1); // (r, distributed z)
      
      // y2 = y1
      memcpy(_checkfield_rz_main, _rz_main, sizeof(complex) * _rz_main_alloc_size);
      
      // a_i = y1
      memcpy(_aifield_rz_main, _rz_main, sizeof(complex) * _rz_main_alloc_size);
      
      _active_rz_main = _akfield_rz_main;
      
      // a_k = G[a_k, t]
      _segment1_calculate_delta_a(_step);
      
      // a_i = D(a_2*dt)[a_k]
      _segment1_ip_evolve(1);
      _rz_main_basis_transform(1); // (r, distributed z)
      
      for (long _i0 = 0; _i0 < (_lattice_r * _local_swapped_lattice_z) * _rz_main_ncomponents; _i0++) {
        // y1 = y1 + c_1*a_k
        _rz_main[_i0] += _c[1]*_akfield_rz_main[_i0];
        // y2 = y2 + cs_1*a_k
        _checkfield_rz_main[_i0] += _cs[1]*_akfield_rz_main[_i0];
        // a_k = a_i + b_21*a_k
        _akfield_rz_main[_i0] = _aifield_rz_main[_i0] + _b[2][1]*_akfield_rz_main[_i0];
      }
      
      
      t += _a[2] * _step;
      
      _segment1_calculate_nonconstant_ip_fields(_step, 2, 1);
      
      _segment1_ip_evolve(-2);
      
      // a_k = G[a_k, t + aa_2*dt]
      _segment1_calculate_delta_a(_step);
      
      _segment1_ip_evolve(2);
      _rz_main_basis_transform(1); // (r, distributed z)
      
      // c_2 == cs_2 == 0
      for (long _i0 = 0; _i0 < (_lattice_r * _local_swapped_lattice_z) * _rz_main_ncomponents; _i0++) {
        // a_j = d_1*a_i + d_2*y1 + d_3*a_k
        _ajfield_rz_main[_i0] = _d[1]*_aifield_rz_main[_i0] + _d[2]*_rz_main[_i0] + _d[3]*_akfield_rz_main[_i0];
      }
      
      
      t += _a[3] * _step;
      
      _active_rz_main = _ajfield_rz_main;
      
      _segment1_calculate_nonconstant_ip_fields(_step, 3, 1);
      
      // a_j = D((a_3 - a_2)*dt)[a_j]
      _segment1_ip_evolve(-3);
      
      // a_j = G[a_j, t + aa_3*dt]
      _segment1_calculate_delta_a(_step);
      
      // a_j = D(-(a_3 - a_2)*dt)[a_j]
      _segment1_ip_evolve(3);
      _rz_main_basis_transform(1); // (r, distributed z)
      
      for (long _i0 = 0; _i0 < (_lattice_r * _local_swapped_lattice_z) * _rz_main_ncomponents; _i0++) {
        // a_l = e_1*a_i + e_2*y1 + e_3*a_k + e_4*a_j
        _alfield_rz_main[_i0] = _e[1]*_aifield_rz_main[_i0] + _e[2]*_rz_main[_i0] + _e[3]*_akfield_rz_main[_i0] + _e[4]*_ajfield_rz_main[_i0];
        // y1 = y1 + c_3*a_j
        _rz_main[_i0] += _c[3]*_ajfield_rz_main[_i0];
        // y2 = y2 + cs_3*a_j
        _checkfield_rz_main[_i0] += _cs[3]*_ajfield_rz_main[_i0];
      }
      
      
      t += _a[4] * _step;
      
      _active_rz_main = _alfield_rz_main;
      
      _segment1_calculate_nonconstant_ip_fields(_step, 4, 1);
      
      // a_l = D((a_4 - a_2)*dt)[a_l]
      _segment1_ip_evolve(-4);
      
      // a_l = G[a_l, t + aa_4*dt]
      _segment1_calculate_delta_a(_step);
      
      // a_l = D(-(a_4 - a_2)*dt)[a_l]
      _segment1_ip_evolve(4);
      _rz_main_basis_transform(1); // (r, distributed z)
      
      for (long _i0 = 0; _i0 < (_lattice_r * _local_swapped_lattice_z) * _rz_main_ncomponents; _i0++) {
        // y1 = y1 + c_4*a_l
        _rz_main[_i0] += _c[4]*_alfield_rz_main[_i0];
        // y2 = y2 + cs_4*a_l
        _checkfield_rz_main[_i0] += _cs[4]*_alfield_rz_main[_i0];
        // a_l = f_1*a_i + f_2*y1 + f_3*a_k + f_4*a_j + f_5*a_l
        _alfield_rz_main[_i0] = _f[1]*_aifield_rz_main[_i0] + _f[2]*_rz_main[_i0] + _f[3]*_akfield_rz_main[_i0] + _f[4]*_ajfield_rz_main[_i0] + _f[5]*_alfield_rz_main[_i0];
      }
      
      
      t += _a[5] * _step;
      
      // a_l = G[a_l, t + aa_5*dt]
      _segment1_calculate_delta_a(_step);
      _rz_main_basis_transform(1); // (r, distributed z)
      
      // c_5 == 0
      for (long _i0 = 0; _i0 < (_lattice_r * _local_swapped_lattice_z) * _rz_main_ncomponents; _i0++) {
        // y2 = y2 + cs_5*a_l
        _checkfield_rz_main[_i0] += _cs[5]*_alfield_rz_main[_i0];
        // a_l = g_1*a_i + g_2*a_k + g_3*a_j + g_4*y_1 + g_5*a_l + g_6*y2
        _alfield_rz_main[_i0] = _g[1]*_aifield_rz_main[_i0] + _g[2]*_akfield_rz_main[_i0] + _g[3]*_ajfield_rz_main[_i0] + _g[4]*_rz_main[_i0] + _g[5]*_alfield_rz_main[_i0] + _g[6]*_checkfield_rz_main[_i0];
      }
      
      
      t += _a[6] * _step;
      
      _segment1_calculate_nonconstant_ip_fields(_step, 5, 1);
      
      // a_l = D((a_6 - a_2)*dt)[a_l]
      _segment1_ip_evolve(-5);
      
      // a_l = G[a_l, t + aa_6*dt]
      _segment1_calculate_delta_a(_step);
      
      // a_l = D(-(a_6 - a_2)*dt)[a_l]
      _segment1_ip_evolve(5);
      _rz_main_basis_transform(1); // (r, distributed z)
      
      // c_5 == 0
      for (long _i0 = 0; _i0 < (_lattice_r * _local_swapped_lattice_z) * _rz_main_ncomponents; _i0++) {
        // y1 = y1 + c_6*a_l
        _rz_main[_i0] += _c[6]*_alfield_rz_main[_i0];
        // y2 = y2 + cs_6*a_l
        _checkfield_rz_main[_i0] += _cs[6]*_alfield_rz_main[_i0];
      }
      
      
      // t -> t + dt
      t -= _a[6]*_step;
      
      _active_rz_main = _checkfield_rz_main;
      
      _active_rz_main = _rz_main;
      
      
      
      _error = 0.0;
      
      _segment1_rz_main_error = _segment1_rz_main_timestep_error(_checkfield_rz_main);
      if (_segment1_rz_main_error > _error)
        _error = _segment1_rz_main_error;
      
      _attempted_steps++;
      
      if (_error < _tolerance) {
        _t_local += _step;
        if (_step > _max_step)
          _max_step = _step;
        if (!_break_next && _step < _min_step)
          _min_step = _step;
        _discard = false;
      } else {
        t -= _step;
  
        if (_segment1_rz_main_reset(_aifield_rz_main) == false) {
  
          _LOG(_WARNING_LOG_LEVEL, "WARNING: NaN present. Integration halted at t = %e.\n"
                             "         Non-finite number in integration vector \"main\" in segment 1.\n", t);
          if (_mg0_output_index_t < _mg0_output_lattice_t)
            _mg0_sample();
          if (_mg1_output_index_t < _mg1_output_lattice_t)
            _mg1_sample();
          if (_mg2_output_index_t < _mg2_output_lattice_t)
            _mg2_sample();
          
          goto _SEGMENT1_END;
        }
  
        _segment1_ip_evolve(-1);
        
        _discard = true;
        _break_next = false;
        _unsuccessful_steps++;
      }
      
      _old_step = _step;
      
      // Resize step
      if (_error < 0.5*_tolerance || _error > _tolerance) {
        const real _safetyFactor = 0.90;
        real _scalingFactor = _safetyFactor * pow(abs(_error/_tolerance), real(-0.7/5.0)) * pow(_last_norm_error, real(0.4/5.0));
        _scalingFactor = MAX(_scalingFactor, 1.0/5.0);
        _scalingFactor = MIN(_scalingFactor, 7.0);
        if (_error > _tolerance && _scalingFactor > 1.0) {
          // If our step failed don't try and increase our step size. That would be silly.
          _scalingFactor = _safetyFactor * pow(abs(_error/_tolerance), real(-1.0/5.0));
        }
        _old_step = _step;
        _last_norm_error = pow(_safetyFactor/_scalingFactor*pow(_last_norm_error, real(0.4/5.0)), real(5.0/0.7));
        _step *= _scalingFactor;
      }
      
    } while (_discard);
    
    if (_break_next) {
      if (_next_sample_flag[0]) {
        _mg0_sample();
        _next_sample_counter[0]++;
      }
      if (_next_sample_flag[1]) {
        _mg1_sample();
        _next_sample_counter[1]++;
      }
      if (_next_sample_flag[2]) {
        _mg2_sample();
        _next_sample_counter[2]++;
      }
      if (_next_sample_flag[3])
        _next_sample_flag[4] = true;
      else {
        _break_next = false;
        _t_break_next = _segment1_setup_sampling(_next_sample_flag, _next_sample_counter);
      }
    }
    
    if ( (_t_local + _step)*(1.0 + _EPSILON) > _t_break_next) {
      _break_next = true;
      _LOG(_SAMPLE_LOG_LEVEL, "Current timestep: %e\n", _old_step);
      _step = _t_break_next - _t_local;
    }
  } while (!_next_sample_flag[4]);
  
  _SEGMENT1_END:;
  
  xmds_free(_rz_segment1_rz_operators_operator0_field);
  _active_rz_segment1_rz_operators_operator0_field = _rz_segment1_rz_operators_operator0_field = NULL;
  
  
  xmds_free(_rz_segment1_rz_operators_operator0_result);
  _active_rz_segment1_rz_operators_operator0_result = _rz_segment1_rz_operators_operator0_result = NULL;
  xmds_free(_segment1_akfield_rz_main);
  xmds_free(_segment1_aifield_rz_main);
  xmds_free(_segment1_ajfield_rz_main);
  xmds_free(_segment1_alfield_rz_main);
  xmds_free(_segment1_checkfield_rz_main);
  
  _LOG(_SEGMENT_LOG_LEVEL, "Segment 1: minimum timestep: %e maximum timestep: %e\n", _min_step, _max_step);
  _LOG(_SEGMENT_LOG_LEVEL, "  Attempted %li steps, %.2f%% steps failed.\n", _attempted_steps, (100.0*_unsuccessful_steps)/_attempted_steps);
}


inline void _segment1_ip_evolve(int _exponent)
{
}
real _segment1_setup_sampling(bool* _next_sample_flag, long* _next_sample_counter)
{
  // The numbers of the moment groups that need to be sampled at the next sampling point.
  // An entry of N+1 means "reached end of integration interval"
  long _momentGroupNumbersNeedingSamplingNext[4];
  long _numberOfMomentGroupsToBeSampledNext = 1;
  
  long _previous_m = 1;
  long _previous_M = 1;
  
  real _t_break_next = (real)100.0;
  _momentGroupNumbersNeedingSamplingNext[0] = 3;
  
  // initialise all flags to false
  for (long _i0 = 0; _i0 < 4; _i0++)
    _next_sample_flag[_i0] = false;
  
  /* Check if moment group needs sampling at the same time as another already discovered sample (or the final time).
   * If so, add this moment group to the to-be-sampled list. If moment group demands sampling earlier than all
   * previously noted moment groups, erase all previous ones from list and set the sample time to this earlier one.
   */
  if (_next_sample_counter[0] * _previous_M == _previous_m * 1000) {
    _momentGroupNumbersNeedingSamplingNext[_numberOfMomentGroupsToBeSampledNext] = 0;
    _numberOfMomentGroupsToBeSampledNext++;
  } else if (_next_sample_counter[0] * _previous_M < _previous_m * 1000) {
    _t_break_next = _next_sample_counter[0] * ((real)100.0) / ((real)1000);
    _numberOfMomentGroupsToBeSampledNext = 1;
    _momentGroupNumbersNeedingSamplingNext[0] = 0;
    _previous_M = 1000;
    _previous_m = _next_sample_counter[0];
  }
  
  if (_next_sample_counter[1] * _previous_M == _previous_m * 1000) {
    _momentGroupNumbersNeedingSamplingNext[_numberOfMomentGroupsToBeSampledNext] = 1;
    _numberOfMomentGroupsToBeSampledNext++;
  } else if (_next_sample_counter[1] * _previous_M < _previous_m * 1000) {
    _t_break_next = _next_sample_counter[1] * ((real)100.0) / ((real)1000);
    _numberOfMomentGroupsToBeSampledNext = 1;
    _momentGroupNumbersNeedingSamplingNext[0] = 1;
    _previous_M = 1000;
    _previous_m = _next_sample_counter[1];
  }
  
  if (_next_sample_counter[2] * _previous_M == _previous_m * 1000) {
    _momentGroupNumbersNeedingSamplingNext[_numberOfMomentGroupsToBeSampledNext] = 2;
    _numberOfMomentGroupsToBeSampledNext++;
  } else if (_next_sample_counter[2] * _previous_M < _previous_m * 1000) {
    _t_break_next = _next_sample_counter[2] * ((real)100.0) / ((real)1000);
    _numberOfMomentGroupsToBeSampledNext = 1;
    _momentGroupNumbersNeedingSamplingNext[0] = 2;
    _previous_M = 1000;
    _previous_m = _next_sample_counter[2];
  }
  
  // _momentGroupNumbersNeedingSamplingNext now contains the complete list of moment groups that need
  // to be sampled at the next sampling point. Set their flags to true.
  for (long _i0 = 0; _i0 < _numberOfMomentGroupsToBeSampledNext; _i0++)
    _next_sample_flag[_momentGroupNumbersNeedingSamplingNext[_i0]] = true;
  
  return _t_break_next;
}

real _segment1_rz_main_timestep_error(complex* _checkfield)
{
  real _error = 1e-24;
  real _temp_error = 0.0;
  real _temp_mod = 0.0;

  
  // Find the peak value for each component of the field
  real _cutoff[_rz_main_ncomponents];
  
  for (long _i0 = 0; _i0 < _rz_main_ncomponents; _i0++)
    _cutoff[_i0] = 0.0;
  
  {
    long _rz_main_index_pointer = 0;
    #define D _active_rz_main[_rz_main_index_pointer + 0]
    for (long _i0 = 0; _i0 < (_lattice_r * _local_swapped_lattice_z); _i0++) {
      for (long _i1 = 0; _i1 < _rz_main_ncomponents; _i1++) {
        _temp_mod = mod2(_rz_main[_rz_main_index_pointer + _i1]);
        if (_xmds_isnonfinite(_temp_mod))
          _cutoff[_i1] = INFINITY;
        else if (_cutoff[_i1] < _temp_mod)
          _cutoff[_i1] = _temp_mod;
      }
    
      _rz_main_index_pointer += _rz_main_ncomponents;
    }
    #undef D
  }
  MPI_Allreduce(MPI_IN_PLACE, _cutoff, _rz_main_ncomponents, MPI_REAL, MPI_MAX, MPI_COMM_WORLD);
  
  for (long _i0 = 0; _i0 < _rz_main_ncomponents; _i0++) {
    if (_xmds_isnonfinite(_cutoff[_i0]))
      // Return an error two times the tolerance in this case because the timestep must be reduced.
      return 2.0*1e-05;
    _cutoff[_i0] *= 0.001;
    _cutoff[_i0] *= 0.001;
  }
  
  {
    long _rz_main_index_pointer = 0;
    #define D _active_rz_main[_rz_main_index_pointer + 0]
    for (long _i0 = 0; _i0 < (_lattice_r * _local_swapped_lattice_z); _i0++) {
      for (long  _i1 = 0; _i1 < _rz_main_ncomponents; _i1++) {
        if (mod2(_rz_main[_rz_main_index_pointer + _i1]) > _cutoff[_i1]) {
          _temp_error = abs(_rz_main[_rz_main_index_pointer + _i1] - _checkfield[_rz_main_index_pointer + _i1]) / (0.5*abs(_rz_main[_rz_main_index_pointer + _i1]) + 0.5*abs(_checkfield[_rz_main_index_pointer + _i1]));
          
          if (_xmds_isnonfinite(_temp_error)) {
            /* For _temp_error to be NaN, both the absolute value of the higher and lower order solutions
               must BOTH be zero. This therefore implies that their difference is zero, and that there is no error. */
            _temp_error = 0.0;
          }
          
          if (_error < _temp_error) // UNVECTORISABLE
            _error = _temp_error;
        }
      }
    
      _rz_main_index_pointer += _rz_main_ncomponents;
    }
    #undef D
  }
  MPI_Allreduce(MPI_IN_PLACE, &_error, 1, MPI_REAL, MPI_MAX, MPI_COMM_WORLD);
  
  return _error;
}

bool _segment1_rz_main_reset(complex* _reset_to_rz_main)
{
  memcpy(_rz_main, _reset_to_rz_main, sizeof(complex) * _rz_main_alloc_size);
  
  /* return false if there's a NaN somewhere in the vector, otherwise return true */
  bool bNoNaNsPresent = true;
  {
    long _rz_main_index_pointer = 0;
    #define D _active_rz_main[_rz_main_index_pointer + 0]
    for (long _i0 = 0; _i0 < (_lattice_r * _local_swapped_lattice_z); _i0++) {
        for (long _i1 = 0; _i1 < _rz_main_ncomponents; _i1++) {
          if (_xmds_isnonfinite(_rz_main[_rz_main_index_pointer + _i1].Re())
            || _xmds_isnonfinite(_rz_main[_rz_main_index_pointer + _i1].Im())) bNoNaNsPresent = false;
        }
    
      _rz_main_index_pointer += _rz_main_ncomponents;
    }
    #undef D
  }
  return bNoNaNsPresent;
}

// EX transverse derivative operator for field rz
void _segment1_rz_operators_evaluate_operator0()
{
  _rz_main_basis_transform(0); // (kz, distributed kr)
  
  long _rz_segment1_rz_operators_operator0_result_index_pointer = 0;
  #define _Lzz_D _active_rz_segment1_rz_operators_operator0_result[_rz_segment1_rz_operators_operator0_result_index_pointer + 0]
  #define _Lrr_D _active_rz_segment1_rz_operators_operator0_result[_rz_segment1_rz_operators_operator0_result_index_pointer + 1]
  
  long _rz_main_index_pointer = 0;
  #define D _active_rz_main[_rz_main_index_pointer + 0]
  
  long _rz_segment1_rz_operators_operator0_field_index_pointer = 0;
  #define Lrr _active_rz_segment1_rz_operators_operator0_field[_rz_segment1_rz_operators_operator0_field_index_pointer + 0]
  #define Lzz _active_rz_segment1_rz_operators_operator0_field[_rz_segment1_rz_operators_operator0_field_index_pointer + 1]
  for (long _i0 = 0; _i0 < (_lattice_kz * _local_unswapped_lattice_kr); _i0++) {
    // Lzz[D]
    _Lzz_D = Lzz * D;
    // Lrr[D]
    _Lrr_D = Lrr * D;
  
    _rz_segment1_rz_operators_operator0_result_index_pointer += _rz_segment1_rz_operators_operator0_result_ncomponents;
    _rz_main_index_pointer += _rz_main_ncomponents;
    _rz_segment1_rz_operators_operator0_field_index_pointer += _rz_segment1_rz_operators_operator0_field_ncomponents;
  }
  #undef _Lzz_D
  #undef _Lrr_D
  #undef D
  #undef Lrr
  #undef Lzz
  
  _rz_segment1_rz_operators_operator0_result_basis = 0;
}


// EX transverse derivative operator for field rz
void _segment1_rz_operators_calculate_operator0_field()
{
  long _rz_segment1_rz_operators_operator0_field_index_pointer = 0;
  #define Lrr _active_rz_segment1_rz_operators_operator0_field[_rz_segment1_rz_operators_operator0_field_index_pointer + 0]
  #define Lzz _active_rz_segment1_rz_operators_operator0_field[_rz_segment1_rz_operators_operator0_field_index_pointer + 1]
  #define kz _kz[_index_kz + 0]
  #define dkz (_dkz * (1.0))
  
  for (long _index_kz = 0; _index_kz < _lattice_kz; _index_kz++) {
    #define kr _kr[_index_kr + _local_unswapped_offset_kr]
    #define dkr (_dkr_array[_index_kr + _local_unswapped_offset_kr] * (1.0))
    
    for (long _index_kr = 0; _index_kr < _local_unswapped_lattice_kr; _index_kr++) {
      // ************** Operator code *****************
      #line 78 "vortex-ce-TF.xmds"
      
      Lrr = - kr*kr;
      Lzz = - kz*kz;
      #line 2363 "ce-vortice-TF.cc"
      // **********************************************
      // Increment index pointers for vectors in field rz (or having the same dimensions)
      _rz_segment1_rz_operators_operator0_field_index_pointer += 1 * _rz_segment1_rz_operators_operator0_field_ncomponents;
      
    }
    #undef kr
    #undef dkr
  }
  #undef kz
  #undef dkz
  #undef Lrr
  #undef Lzz
}

void _rz_segment1_rz_operators_operator0_result_basis_transform(ptrdiff_t new_basis)
{
  if (_rz_segment1_rz_operators_operator0_result_basis == new_basis)
    return;
  
  if (_rz_segment1_rz_operators_operator0_result_basis == -1) {
    _LOG(
      _ERROR_LOG_LEVEL,
      "Error: Attempted to transform the vector 'rz_segment1_rz_operators_operator0_result' to basis %s, but the vector doesn't have a basis specified yet!\n"
      "       Please report this error to xmds-devel@lists.sourceforge.net\n",
      _basis_identifiers[new_basis]
      );
  }
  
  if (_rz_segment1_rz_operators_operator0_result_basis_map.count(_basis_pair(_rz_segment1_rz_operators_operator0_result_basis, new_basis)) == 0) {
    _LOG(
      _ERROR_LOG_LEVEL,
      "Error: We should have information about how to do every needed transform, but it seems we don't for this transform.\n"
      "       The transform is for the vector 'rz_segment1_rz_operators_operator0_result' from basis %s to basis %s.\n",
      _basis_identifiers[_rz_segment1_rz_operators_operator0_result_basis], _basis_identifiers[new_basis]
    );
  }
  _basis_transform_t &_t = _rz_segment1_rz_operators_operator0_result_basis_map[_basis_pair(_rz_segment1_rz_operators_operator0_result_basis, new_basis)];
  if (_t._transform_steps.size() == 0) {
    _LOG(_ERROR_LOG_LEVEL, "Error: It looks like we tried to create plans for this transform, but failed.\n"
                           "       The transform was for the vector 'rz_segment1_rz_operators_operator0_result' from basis %s to basis %s.\n",
                           _basis_identifiers[_rz_segment1_rz_operators_operator0_result_basis], _basis_identifiers[new_basis]);
  }
  real *_source_data = reinterpret_cast<real*>(_active_rz_segment1_rz_operators_operator0_result);
  real *_dest_data = _auxiliary_array;
  for (vector<_transform_step>::iterator _it = _t._transform_steps.begin(); _it != _t._transform_steps.end(); ++_it) {
    _it->_func(_it->_forward, _t._multiplier, _source_data, _dest_data, _it->_prefix_lattice, _it->_postfix_lattice);
    if (_it->_out_of_place) {
      real *_temp = _source_data;
      _source_data = _dest_data;
      _dest_data = _temp;
    }
  }
  _rz_segment1_rz_operators_operator0_result_basis = new_basis;
}

// Delta A propagation operator for field rz
void _segment1_rz_operators_evaluate_operator1(real _step)
{
  _rz_segment1_rz_operators_operator0_result_basis_transform(1); // (r, distributed z)
  _rz_main_basis_transform(1); // (r, distributed z)
  
  long _rz_segment1_rz_operators_operator0_result_index_pointer = 0;
  #define _Lzz_D _active_rz_segment1_rz_operators_operator0_result[_rz_segment1_rz_operators_operator0_result_index_pointer + 0]
  #define _Lrr_D _active_rz_segment1_rz_operators_operator0_result[_rz_segment1_rz_operators_operator0_result_index_pointer + 1]
  long _rz_main_index_pointer = 0;
  #define D _active_rz_main[_rz_main_index_pointer + 0]
  #define r _r[_index_r + 0]
  #define dr (_dr_array[_index_r + 0] * (1.0))
  
  for (long _index_r = 0; _index_r < _lattice_r; _index_r++) {
    #define z _z[_index_z + _local_swapped_offset_z]
    #define dz (_dz * (1.0))
    
    for (long _index_z = 0; _index_z < _local_swapped_lattice_z; _index_z++) {
      complex dD_dt;
      
      #define dt _step
      
      // ************* Propagation code ***************
      #line 84 "vortex-ce-TF.xmds"
      
      dD_dt = i*(0.5*(_Lrr_D + _Lzz_D) - ((4.0*M_PI*g*mod2(D) + 0.5*(r*r + lamb*lamb*z*z) - mu)*D));
      #line 2446 "ce-vortice-TF.cc"
      // **********************************************
      
      #undef dt
      
      
      _active_rz_main[_rz_main_index_pointer + 0] = dD_dt * _step;
      // Increment index pointers for vectors in field rz (or having the same dimensions)
      _rz_segment1_rz_operators_operator0_result_index_pointer += 1 * _rz_segment1_rz_operators_operator0_result_ncomponents;
      _rz_main_index_pointer += 1 * _rz_main_ncomponents;
      
    }
    #undef z
    #undef dz
  }
  #undef r
  #undef dr
  #undef _Lzz_D
  #undef _Lrr_D
  #undef D
}

// ********************************************************
//   output function implementations
void _write_output()
{
  _LOG(_SIMULATION_LOG_LEVEL, "Generating output for ce-vortice-TF\n");
  
  
  char *_xsilFilename = (char*)malloc(256);
  snprintf(_xsilFilename, 256, "%s.xsil", ("vortex-ce-TF" + gsArgsAndValues).c_str());
  
  FILE* _outfile = _open_xsil_file(_xsilFilename);
  
  if (_outfile) {
    _write_xsil_header(_outfile);
    char _dataFilename[200];
    snprintf(_dataFilename, 200, "%s.h5", ("vortex-ce-TF" + gsArgsAndValues).c_str());
    
    H5Fclose(H5Fcreate(_dataFilename, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT));
  }
  _mg0_write_out(_outfile);
  _mg1_write_out(_outfile);
  _mg2_write_out(_outfile);
  
  _write_xsil_footer(_outfile);
  _close_xsil_file(_outfile);
  free(_xsilFilename);
  _xsilFilename = NULL;
  _outfile = NULL;
  
}


FILE* _open_xsil_file(const char* _filename)
{
  // Only let rank 0 do the writing to disk
  if (_rank != 0)
    return NULL;
  
  FILE* fp = fopen(_filename, "w");
  
  if (fp == NULL)
    // _LOG will cause the simulation to exit
    _LOG(_ERROR_LOG_LEVEL, "Unable to open output file '%s'.\n"
                           "Exiting.\n", _filename);
  
  return fp;
}

void _close_xsil_file(FILE*& fp)
{
  if (fp)
    fclose(fp);
  fp = NULL;
  
}

void _write_xsil_header(FILE* fp)
{
  if (!fp)
    return;
  fprintf(fp, "<simulation xmds-version=\"2\">\n");
  fprintf(fp, "  <name>ce-vortice-TF</name>\n");
  fprintf(fp, "  <author>R. P. Teles</author>\n");
  fprintf(fp, "  <description>\n");
  fprintf(fp, "    Ground state of 3D GPE containhg a central vortex.\n");
  fprintf(fp, "  </description>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <features>\n");
  fprintf(fp, "    <benchmark />\n");
  fprintf(fp, "    <arguments>\n");
  fprintf(fp, "      <argument name=\"mu\"     type=\"real\" default_value=\"20.74\" />\n");
  fprintf(fp, "      <argument name=\"g\"      type=\"real\" default_value=\"800.0\" />\n");
  fprintf(fp, "      <argument name=\"lamb\"     type=\"real\" default_value=\"0.9\" />\n");
  fprintf(fp, "      <argument name=\"R\"     type=\"real\" default_value=\"6.4219\" />\n");
  fprintf(fp, "      <argument name=\"Z\"     type=\"real\" default_value=\"7.10582\" />\n");
  fprintf(fp, "      <argument name=\"X\"     type=\"real\" default_value=\"0.255784\" />\n");
  fprintf(fp, "      <argument name=\"A\"     type=\"real\" default_value=\"0.0455999\" />\n");
  fprintf(fp, "    </arguments>\n");
  fprintf(fp, "    <bing />\n");
  fprintf(fp, "    <fftw plan=\"patient\" />\n");
  fprintf(fp, "  </features>\n");
  fprintf(fp, "\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <geometry>\n");
  fprintf(fp, "    <propagation_dimension> t </propagation_dimension>\n");
  fprintf(fp, "    <transverse_dimensions>\n");
  fprintf(fp, "      <dimension name=\"r\" lattice=\"128\"  domain=\"(0, 15)\" transform=\"bessel\" order=\"1\" />\n");
  fprintf(fp, "      <dimension name=\"z\" lattice=\"128\"  domain=\"(-15, 15)\" />\n");
  fprintf(fp, "    </transverse_dimensions>\n");
  fprintf(fp, "  </geometry>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <driver name=\"distributed-mpi\" />\n");
  fprintf(fp, "    \n");
  fprintf(fp, "  <vector name=\"init\" type=\"real\" dimensions=\"r z\">\n");
  fprintf(fp, "    <components> DI </components>\n");
  fprintf(fp, "    <initialisation>\n");
  fprintf(fp, "      <![CDATA[\n");
  fprintf(fp, "       if ((1 - r*r/(R*R) - z*z/(Z*Z)) > 0) {\n");
  fprintf(fp, "          DI = A*sqrt(r*r/(r*r+X*X))*sqrt(1 - r*r/(R*R) - z*z/(Z*Z));\n");
  fprintf(fp, "          // This will be automatically normalised later\n");
  fprintf(fp, "        } else {\n");
  fprintf(fp, "          DI = 0.0;\n");
  fprintf(fp, "        }\n");
  fprintf(fp, "      ]]>\n");
  fprintf(fp, "     </initialisation>\n");
  fprintf(fp, "  </vector>\n");
  fprintf(fp, "\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <vector name=\"main\" initial_space=\"r z\" type=\"complex\">\n");
  fprintf(fp, "    <components> D </components>\n");
  fprintf(fp, "    <initialisation>\n");
  fprintf(fp, "      <dependencies>init</dependencies>\n");
  fprintf(fp, "      <![CDATA[\n");
  fprintf(fp, "       D = DI;\n");
  fprintf(fp, "      ]]>\n");
  fprintf(fp, "    </initialisation>\n");
  fprintf(fp, "  </vector>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  \n");
  fprintf(fp, "  <computed_vector name=\"normalisation\" dimensions=\"\" type=\"real\">\n");
  fprintf(fp, "    <components> Ncalc </components>\n");
  fprintf(fp, "    <evaluation>\n");
  fprintf(fp, "      <dependencies basis=\"r z\">main</dependencies>\n");
  fprintf(fp, "      <![CDATA[\n");
  fprintf(fp, "        // Calculate the current normalisation of the wave function.\n");
  fprintf(fp, "        Ncalc = 2.0*M_PI*mod2(D);\n");
  fprintf(fp, "      ]]>\n");
  fprintf(fp, "    </evaluation>\n");
  fprintf(fp, "  </computed_vector>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <sequence>\n");
  fprintf(fp, "    \n");
  fprintf(fp, "    <integrate algorithm=\"ARK45\" tolerance=\"1e-5\" interval=\"100.0\" steps=\"100000\">\n");
  fprintf(fp, "      <samples>1000 1000 1000</samples>\n");
  fprintf(fp, "      <operators>\n");
  fprintf(fp, "        <operator kind=\"ex\" constant=\"yes\">\n");
  fprintf(fp, "          <operator_names>Lrr Lzz</operator_names>\n");
  fprintf(fp, "          <![CDATA[\n");
  fprintf(fp, "              Lrr = - kr*kr;\n");
  fprintf(fp, "              Lzz = - kz*kz;\n");
  fprintf(fp, "          ]]>\n");
  fprintf(fp, "        </operator>\n");
  fprintf(fp, "        <integration_vectors>main</integration_vectors>\n");
  fprintf(fp, "         <![CDATA[\n");
  fprintf(fp, "                dD_dt = i*(0.5*(Lrr[D] + Lzz[D]) - ((4.0*M_PI*g*mod2(D) + 0.5*(r*r + lamb*lamb*z*z) - mu)*D));\n");
  fprintf(fp, "        ]]>\n");
  fprintf(fp, "      </operators>\n");
  fprintf(fp, "    </integrate>\n");
  fprintf(fp, "  </sequence>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <output format=\"hdf5\" filename=\"vortex-ce-TF.xsil\">      \n");
  fprintf(fp, "      <sampling_group basis=\"r(0) z(0)\" initial_sample=\"yes\">\n");
  fprintf(fp, "        <moments>Dr</moments>\n");
  fprintf(fp, "        <dependencies>main</dependencies>\n");
  fprintf(fp, "        <![CDATA[\n");
  fprintf(fp, "            \n");
  fprintf(fp, "          Dr = 2.0*M_PI*r*r*mod2(D);\n");
  fprintf(fp, "            \n");
  fprintf(fp, "        ]]>\n");
  fprintf(fp, "      </sampling_group>\n");
  fprintf(fp, "    \n");
  fprintf(fp, "      <sampling_group basis=\"r(0) z(0)\" initial_sample=\"yes\">\n");
  fprintf(fp, "        <moments>Dz</moments>\n");
  fprintf(fp, "        <dependencies>main</dependencies>\n");
  fprintf(fp, "        <![CDATA[\n");
  fprintf(fp, "            \n");
  fprintf(fp, "          Dz = 2*M_PI*z*z*mod2(D);\n");
  fprintf(fp, "            \n");
  fprintf(fp, "        ]]>\n");
  fprintf(fp, "      </sampling_group>\n");
  fprintf(fp, "\n");
  fprintf(fp, "<sampling_group basis=\"r(0) z(0)\" initial_sample=\"yes\">\n");
  fprintf(fp, "        <moments>Dn</moments>\n");
  fprintf(fp, "        <dependencies>main</dependencies>\n");
  fprintf(fp, "        <![CDATA[\n");
  fprintf(fp, "            \n");
  fprintf(fp, "          Dn = 2*M_PI*mod2(D);\n");
  fprintf(fp, "            \n");
  fprintf(fp, "        ]]>\n");
  fprintf(fp, "      </sampling_group>\n");
  fprintf(fp, "    \n");
  fprintf(fp, "   \n");
  fprintf(fp, "  </output>\n");
  fprintf(fp, "    \n");
  fprintf(fp, "  \n");
  fprintf(fp, "\n");
  
  fprintf(fp, "\n<info>\n");
  fprintf(fp, "Script compiled with XMDS2 version 2.1.2 \"Happy Mollusc\" (r2791)\n");
  fprintf(fp, "See http://www.xmds.org for more information.\n");
  fprintf(fp, "\nVariables that can be specified on the command line:\n");
  
  fprintf(fp, "  Command line argument mu = %e\n", mu);
  
  fprintf(fp, "  Command line argument g = %e\n", g);
  
  fprintf(fp, "  Command line argument lamb = %e\n", lamb);
  
  fprintf(fp, "  Command line argument R = %e\n", R);
  
  fprintf(fp, "  Command line argument Z = %e\n", Z);
  
  fprintf(fp, "  Command line argument X = %e\n", X);
  
  fprintf(fp, "  Command line argument A = %e\n", A);
  fprintf(fp, "</info>\n");
  
}

// In addition to writing the footer (if 'fp' is not NULL)
// this function closes the fp file pointer.
void _write_xsil_footer(FILE* fp)
{
  if (fp) {
    fprintf(fp, "</simulation>\n");
  }
}

// ********************************************************
//   moment group 0 function implementations
void _mg0_sample()
{
  
  _rz_main_basis_transform(1); // (r, distributed z)
  
  long _mg0_output_raw_index_pointer = 0;
  real Dr;
  long _rz_main_index_pointer = 0;
  #define D _active_rz_main[_rz_main_index_pointer + 0]
  #define r _r[_index_r + 0]
  #define dr (_dr_array[_index_r + 0] * (1.0))
  
  for (long _index_r = 0; _index_r < _lattice_r; _index_r++) {
    #define z _z[_index_z + _local_swapped_offset_z]
    #define dz (_dz * (1.0))
    
    for (long _index_z = 0; _index_z < _local_swapped_lattice_z; _index_z++) {
      // Set index pointers explicitly for (some) vectors
      _mg0_output_raw_index_pointer = ( 0
         + _mg0_output_index_t  * 1 ) * _mg0_output_raw_ncomponents;
      #define _SAMPLE_COMPLEX(variable) \
                variable ## R = variable.Re(); variable ## I = variable.Im();
      
      // *************** Sampling code ****************
      #line 95 "vortex-ce-TF.xmds"
      
      
      Dr = 2.0*M_PI*r*r*mod2(D);
      
      #line 2717 "ce-vortice-TF.cc"
      // **********************************************
      
      #undef _SAMPLE_COMPLEX
      
      _active_mg0_output_raw[_mg0_output_raw_index_pointer + 0] += Dr * dr * dz;
      // Increment index pointers for vectors in field mg0_sampling (or having the same dimensions)
      _rz_main_index_pointer += 1 * _rz_main_ncomponents;
      
    }
    #undef z
    #undef dz
  }
  #undef r
  #undef dr
  #undef D
  MPI_Allreduce(MPI_IN_PLACE, _active_mg0_output_raw + _mg0_output_index_t * 1 * _mg0_output_raw_ncomponents, (_mg0_output_lattice_t) * _mg0_output_raw_ncomponents / _mg0_output_lattice_t,
                MPI_REAL, MPI_SUM, MPI_COMM_WORLD);
  
  _mg0_output_t[0 + _mg0_output_index_t++] = t;
  
  _LOG(_SAMPLE_LOG_LEVEL, "Sampled field (for moment group #1) at t = %e\n", t);
  
}


void _mg0_process()
{
  // No post processing needs to be done
}


void _mg0_write_out(FILE* _outfile)
{
  
  if (_outfile) {
    fprintf(_outfile, "\n");
    fprintf(_outfile, "<XSIL Name=\"moment_group_1\">\n");
    fprintf(_outfile, "  <Param Name=\"n_independent\">1</Param>\n");
    fprintf(_outfile, "  <Array Name=\"variables\" Type=\"Text\">\n");
    fprintf(_outfile, "    <Dim>2</Dim>\n");
    fprintf(_outfile, "    <Stream><Metalink Format=\"Text\" Delimiter=\" \\n\"/>\n");
    fprintf(_outfile, "t Dr \n");
    fprintf(_outfile, "    </Stream>\n");
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "  <Array Name=\"data\" Type=\"double\">\n");
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _mg0_output_lattice_t);
    fprintf(_outfile, "    <Dim>2</Dim>\n");
  }
  
  // Only write to file if we are rank 0, as we cannot assume
  // that the nodes have equal access to the filesystem
  if (_rank == 0) {
  
    char _h5Filename[200];
    snprintf(_h5Filename, 200, "%s.h5", ("vortex-ce-TF" + gsArgsAndValues).c_str());
    
    /* Open the file */
    hid_t hdf5_file = H5Fopen(_h5Filename, H5F_ACC_RDWR, H5P_DEFAULT);
    
    /* Create the group for this data */
    hid_t group;
    if (!H5Lexists(hdf5_file, "/1", H5P_DEFAULT))
      group = H5Gcreate(hdf5_file, "/1", H5P_DEFAULT);
    else
      group = H5Gopen(hdf5_file, "/1");
    
    if (_outfile) {
      fprintf(_outfile, "    <Stream><Metalink Format=\"HDF5\" Type=\"Remote\" Group=\"/1\"/>\n");
      fprintf(_outfile, "%s.h5\n", ("vortex-ce-TF" + gsArgsAndValues).c_str());
      fprintf(_outfile, "    </Stream>\n");
    }
    
    /* Create the coordinate data sets */
    hsize_t coordinate_length;
    hid_t coordinate_dataspace;
    coordinate_length = _mg0_output_lattice_t;
    coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
    hid_t dataset_t;
    if (!H5Lexists(hdf5_file, "/1/t", H5P_DEFAULT))
      dataset_t = H5Dcreate(hdf5_file, "/1/t", H5T_NATIVE_REAL, coordinate_dataspace, H5P_DEFAULT);
    else
      dataset_t = H5Dopen(hdf5_file, "/1/t");
    H5Dwrite(dataset_t, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, _mg0_output_t);
    #if defined(HAVE_HDF5_HL)
      H5DSset_scale(dataset_t, "t");
    #endif
    
    H5Sclose(coordinate_dataspace);
    
    hsize_t file_dims[] = {_mg0_output_lattice_t};
    hid_t file_dataspace = H5Screate_simple(1, file_dims, NULL);
    
    hid_t dataset_Dr;
    if (!H5Lexists(hdf5_file, "/1/Dr", H5P_DEFAULT))
      dataset_Dr = H5Dcreate(hdf5_file, "/1/Dr", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
    else
      dataset_Dr = H5Dopen(hdf5_file, "/1/Dr");
    #if defined(HAVE_HDF5_HL)
      H5DSattach_scale(dataset_Dr, dataset_t, 0);
    #endif
    H5Dclose(dataset_t);
    
    
    if ((_mg0_output_lattice_t)) {
      /* Create the data space */
      hsize_t file_start[1] = {0};
      hsize_t mem_dims[2] = {_mg0_output_lattice_t, 1};
      hsize_t mem_start[2] = {0, 0};
      hsize_t mem_stride[2] = {1, 1};
      hsize_t mem_count[2] = {_mg0_output_lattice_t, 1};
      
      
      hid_t mem_dataspace;
      mem_dims[1] = 1;
      mem_dataspace = H5Screate_simple(2, mem_dims, NULL);
      mem_stride[1] = 1;
      
      // Select hyperslabs of memory and file data spaces for data transfer operation
      mem_start[1] = 0;
      H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
      H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
      
      if (dataset_Dr)
        H5Dwrite(dataset_Dr, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_mg0_output_raw);
      
      H5Sclose(mem_dataspace);
    }
    
    
    H5Dclose(dataset_Dr);
    
    H5Sclose(file_dataspace);
    H5Gclose(group);
    H5Fclose(hdf5_file);
  
  }
  
  if (_outfile) {
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "</XSIL>\n");
  }
}

// ********************************************************
//   field mg0_output function implementations
// initialisation for vector raw
void _mg0_output_raw_initialise()
{
  
  bzero(_active_mg0_output_raw, sizeof(real) * _mg0_output_raw_alloc_size);
}

// ********************************************************
//   moment group 1 function implementations
void _mg1_sample()
{
  
  _rz_main_basis_transform(1); // (r, distributed z)
  
  long _mg1_output_raw_index_pointer = 0;
  real Dz;
  long _rz_main_index_pointer = 0;
  #define D _active_rz_main[_rz_main_index_pointer + 0]
  #define r _r[_index_r + 0]
  #define dr (_dr_array[_index_r + 0] * (1.0))
  
  for (long _index_r = 0; _index_r < _lattice_r; _index_r++) {
    #define z _z[_index_z + _local_swapped_offset_z]
    #define dz (_dz * (1.0))
    
    for (long _index_z = 0; _index_z < _local_swapped_lattice_z; _index_z++) {
      // Set index pointers explicitly for (some) vectors
      _mg1_output_raw_index_pointer = ( 0
         + _mg1_output_index_t  * 1 ) * _mg1_output_raw_ncomponents;
      #define _SAMPLE_COMPLEX(variable) \
                variable ## R = variable.Re(); variable ## I = variable.Im();
      
      // *************** Sampling code ****************
      #line 105 "vortex-ce-TF.xmds"
      
      
      Dz = 2*M_PI*z*z*mod2(D);
      
      #line 2901 "ce-vortice-TF.cc"
      // **********************************************
      
      #undef _SAMPLE_COMPLEX
      
      _active_mg1_output_raw[_mg1_output_raw_index_pointer + 0] += Dz * dr * dz;
      // Increment index pointers for vectors in field mg1_sampling (or having the same dimensions)
      _rz_main_index_pointer += 1 * _rz_main_ncomponents;
      
    }
    #undef z
    #undef dz
  }
  #undef r
  #undef dr
  #undef D
  MPI_Allreduce(MPI_IN_PLACE, _active_mg1_output_raw + _mg1_output_index_t * 1 * _mg1_output_raw_ncomponents, (_mg1_output_lattice_t) * _mg1_output_raw_ncomponents / _mg1_output_lattice_t,
                MPI_REAL, MPI_SUM, MPI_COMM_WORLD);
  
  _mg1_output_t[0 + _mg1_output_index_t++] = t;
  
  _LOG(_SAMPLE_LOG_LEVEL, "Sampled field (for moment group #2) at t = %e\n", t);
  
}


void _mg1_process()
{
  // No post processing needs to be done
}


void _mg1_write_out(FILE* _outfile)
{
  
  if (_outfile) {
    fprintf(_outfile, "\n");
    fprintf(_outfile, "<XSIL Name=\"moment_group_2\">\n");
    fprintf(_outfile, "  <Param Name=\"n_independent\">1</Param>\n");
    fprintf(_outfile, "  <Array Name=\"variables\" Type=\"Text\">\n");
    fprintf(_outfile, "    <Dim>2</Dim>\n");
    fprintf(_outfile, "    <Stream><Metalink Format=\"Text\" Delimiter=\" \\n\"/>\n");
    fprintf(_outfile, "t Dz \n");
    fprintf(_outfile, "    </Stream>\n");
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "  <Array Name=\"data\" Type=\"double\">\n");
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _mg1_output_lattice_t);
    fprintf(_outfile, "    <Dim>2</Dim>\n");
  }
  
  // Only write to file if we are rank 0, as we cannot assume
  // that the nodes have equal access to the filesystem
  if (_rank == 0) {
  
    char _h5Filename[200];
    snprintf(_h5Filename, 200, "%s.h5", ("vortex-ce-TF" + gsArgsAndValues).c_str());
    
    /* Open the file */
    hid_t hdf5_file = H5Fopen(_h5Filename, H5F_ACC_RDWR, H5P_DEFAULT);
    
    /* Create the group for this data */
    hid_t group;
    if (!H5Lexists(hdf5_file, "/2", H5P_DEFAULT))
      group = H5Gcreate(hdf5_file, "/2", H5P_DEFAULT);
    else
      group = H5Gopen(hdf5_file, "/2");
    
    if (_outfile) {
      fprintf(_outfile, "    <Stream><Metalink Format=\"HDF5\" Type=\"Remote\" Group=\"/2\"/>\n");
      fprintf(_outfile, "%s.h5\n", ("vortex-ce-TF" + gsArgsAndValues).c_str());
      fprintf(_outfile, "    </Stream>\n");
    }
    
    /* Create the coordinate data sets */
    hsize_t coordinate_length;
    hid_t coordinate_dataspace;
    coordinate_length = _mg1_output_lattice_t;
    coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
    hid_t dataset_t;
    if (!H5Lexists(hdf5_file, "/2/t", H5P_DEFAULT))
      dataset_t = H5Dcreate(hdf5_file, "/2/t", H5T_NATIVE_REAL, coordinate_dataspace, H5P_DEFAULT);
    else
      dataset_t = H5Dopen(hdf5_file, "/2/t");
    H5Dwrite(dataset_t, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, _mg1_output_t);
    #if defined(HAVE_HDF5_HL)
      H5DSset_scale(dataset_t, "t");
    #endif
    
    H5Sclose(coordinate_dataspace);
    
    hsize_t file_dims[] = {_mg1_output_lattice_t};
    hid_t file_dataspace = H5Screate_simple(1, file_dims, NULL);
    
    hid_t dataset_Dz;
    if (!H5Lexists(hdf5_file, "/2/Dz", H5P_DEFAULT))
      dataset_Dz = H5Dcreate(hdf5_file, "/2/Dz", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
    else
      dataset_Dz = H5Dopen(hdf5_file, "/2/Dz");
    #if defined(HAVE_HDF5_HL)
      H5DSattach_scale(dataset_Dz, dataset_t, 0);
    #endif
    H5Dclose(dataset_t);
    
    
    if ((_mg1_output_lattice_t)) {
      /* Create the data space */
      hsize_t file_start[1] = {0};
      hsize_t mem_dims[2] = {_mg1_output_lattice_t, 1};
      hsize_t mem_start[2] = {0, 0};
      hsize_t mem_stride[2] = {1, 1};
      hsize_t mem_count[2] = {_mg1_output_lattice_t, 1};
      
      
      hid_t mem_dataspace;
      mem_dims[1] = 1;
      mem_dataspace = H5Screate_simple(2, mem_dims, NULL);
      mem_stride[1] = 1;
      
      // Select hyperslabs of memory and file data spaces for data transfer operation
      mem_start[1] = 0;
      H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
      H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
      
      if (dataset_Dz)
        H5Dwrite(dataset_Dz, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_mg1_output_raw);
      
      H5Sclose(mem_dataspace);
    }
    
    
    H5Dclose(dataset_Dz);
    
    H5Sclose(file_dataspace);
    H5Gclose(group);
    H5Fclose(hdf5_file);
  
  }
  
  if (_outfile) {
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "</XSIL>\n");
  }
}

// ********************************************************
//   field mg1_output function implementations
// initialisation for vector raw
void _mg1_output_raw_initialise()
{
  
  bzero(_active_mg1_output_raw, sizeof(real) * _mg1_output_raw_alloc_size);
}

// ********************************************************
//   moment group 2 function implementations
void _mg2_sample()
{
  
  _rz_main_basis_transform(1); // (r, distributed z)
  
  long _rz_main_index_pointer = 0;
  #define D _active_rz_main[_rz_main_index_pointer + 0]
  long _mg2_output_raw_index_pointer = 0;
  real Dn;
  #define r _r[_index_r + 0]
  #define dr (_dr_array[_index_r + 0] * (1.0))
  
  for (long _index_r = 0; _index_r < _lattice_r; _index_r++) {
    #define z _z[_index_z + _local_swapped_offset_z]
    #define dz (_dz * (1.0))
    
    for (long _index_z = 0; _index_z < _local_swapped_lattice_z; _index_z++) {
      // Set index pointers explicitly for (some) vectors
      _mg2_output_raw_index_pointer = ( 0
         + _mg2_output_index_t  * 1 ) * _mg2_output_raw_ncomponents;
      #define _SAMPLE_COMPLEX(variable) \
                variable ## R = variable.Re(); variable ## I = variable.Im();
      
      // *************** Sampling code ****************
      #line 115 "vortex-ce-TF.xmds"
      
      
      Dn = 2*M_PI*mod2(D);
      
      #line 3085 "ce-vortice-TF.cc"
      // **********************************************
      
      #undef _SAMPLE_COMPLEX
      
      _active_mg2_output_raw[_mg2_output_raw_index_pointer + 0] += Dn * dr * dz;
      // Increment index pointers for vectors in field mg2_sampling (or having the same dimensions)
      _rz_main_index_pointer += 1 * _rz_main_ncomponents;
      
    }
    #undef z
    #undef dz
  }
  #undef r
  #undef dr
  #undef D
  MPI_Allreduce(MPI_IN_PLACE, _active_mg2_output_raw + _mg2_output_index_t * 1 * _mg2_output_raw_ncomponents, (_mg2_output_lattice_t) * _mg2_output_raw_ncomponents / _mg2_output_lattice_t,
                MPI_REAL, MPI_SUM, MPI_COMM_WORLD);
  
  _mg2_output_t[0 + _mg2_output_index_t++] = t;
  
  _LOG(_SAMPLE_LOG_LEVEL, "Sampled field (for moment group #3) at t = %e\n", t);
  
}


void _mg2_process()
{
  // No post processing needs to be done
}


void _mg2_write_out(FILE* _outfile)
{
  
  if (_outfile) {
    fprintf(_outfile, "\n");
    fprintf(_outfile, "<XSIL Name=\"moment_group_3\">\n");
    fprintf(_outfile, "  <Param Name=\"n_independent\">1</Param>\n");
    fprintf(_outfile, "  <Array Name=\"variables\" Type=\"Text\">\n");
    fprintf(_outfile, "    <Dim>2</Dim>\n");
    fprintf(_outfile, "    <Stream><Metalink Format=\"Text\" Delimiter=\" \\n\"/>\n");
    fprintf(_outfile, "t Dn \n");
    fprintf(_outfile, "    </Stream>\n");
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "  <Array Name=\"data\" Type=\"double\">\n");
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _mg2_output_lattice_t);
    fprintf(_outfile, "    <Dim>2</Dim>\n");
  }
  
  // Only write to file if we are rank 0, as we cannot assume
  // that the nodes have equal access to the filesystem
  if (_rank == 0) {
  
    char _h5Filename[200];
    snprintf(_h5Filename, 200, "%s.h5", ("vortex-ce-TF" + gsArgsAndValues).c_str());
    
    /* Open the file */
    hid_t hdf5_file = H5Fopen(_h5Filename, H5F_ACC_RDWR, H5P_DEFAULT);
    
    /* Create the group for this data */
    hid_t group;
    if (!H5Lexists(hdf5_file, "/3", H5P_DEFAULT))
      group = H5Gcreate(hdf5_file, "/3", H5P_DEFAULT);
    else
      group = H5Gopen(hdf5_file, "/3");
    
    if (_outfile) {
      fprintf(_outfile, "    <Stream><Metalink Format=\"HDF5\" Type=\"Remote\" Group=\"/3\"/>\n");
      fprintf(_outfile, "%s.h5\n", ("vortex-ce-TF" + gsArgsAndValues).c_str());
      fprintf(_outfile, "    </Stream>\n");
    }
    
    /* Create the coordinate data sets */
    hsize_t coordinate_length;
    hid_t coordinate_dataspace;
    coordinate_length = _mg2_output_lattice_t;
    coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
    hid_t dataset_t;
    if (!H5Lexists(hdf5_file, "/3/t", H5P_DEFAULT))
      dataset_t = H5Dcreate(hdf5_file, "/3/t", H5T_NATIVE_REAL, coordinate_dataspace, H5P_DEFAULT);
    else
      dataset_t = H5Dopen(hdf5_file, "/3/t");
    H5Dwrite(dataset_t, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, _mg2_output_t);
    #if defined(HAVE_HDF5_HL)
      H5DSset_scale(dataset_t, "t");
    #endif
    
    H5Sclose(coordinate_dataspace);
    
    hsize_t file_dims[] = {_mg2_output_lattice_t};
    hid_t file_dataspace = H5Screate_simple(1, file_dims, NULL);
    
    hid_t dataset_Dn;
    if (!H5Lexists(hdf5_file, "/3/Dn", H5P_DEFAULT))
      dataset_Dn = H5Dcreate(hdf5_file, "/3/Dn", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
    else
      dataset_Dn = H5Dopen(hdf5_file, "/3/Dn");
    #if defined(HAVE_HDF5_HL)
      H5DSattach_scale(dataset_Dn, dataset_t, 0);
    #endif
    H5Dclose(dataset_t);
    
    
    if ((_mg2_output_lattice_t)) {
      /* Create the data space */
      hsize_t file_start[1] = {0};
      hsize_t mem_dims[2] = {_mg2_output_lattice_t, 1};
      hsize_t mem_start[2] = {0, 0};
      hsize_t mem_stride[2] = {1, 1};
      hsize_t mem_count[2] = {_mg2_output_lattice_t, 1};
      
      
      hid_t mem_dataspace;
      mem_dims[1] = 1;
      mem_dataspace = H5Screate_simple(2, mem_dims, NULL);
      mem_stride[1] = 1;
      
      // Select hyperslabs of memory and file data spaces for data transfer operation
      mem_start[1] = 0;
      H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
      H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
      
      if (dataset_Dn)
        H5Dwrite(dataset_Dn, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_mg2_output_raw);
      
      H5Sclose(mem_dataspace);
    }
    
    
    H5Dclose(dataset_Dn);
    
    H5Sclose(file_dataspace);
    H5Gclose(group);
    H5Fclose(hdf5_file);
  
  }
  
  if (_outfile) {
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "</XSIL>\n");
  }
}

// ********************************************************
//   field mg2_output function implementations
// initialisation for vector raw
void _mg2_output_raw_initialise()
{
  
  bzero(_active_mg2_output_raw, sizeof(real) * _mg2_output_raw_alloc_size);
}

